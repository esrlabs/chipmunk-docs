<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="user-guide"><a class="header" href="#user-guide">User Guide</a></h1>
<p>This guide describes the most common usecases for using chipmunk.</p>
<h2 id="searching-and-filtering"><a class="header" href="#searching-and-filtering"><a href="01_usage/searching_and_filtering">Searching and Filtering</a></a></h2>
<img src="01_usage/../images/magnifying-search-lenses-tool.png" width="100" height="100">
<p>Searching through huge logfiles</p>
<h2 id="bookmarks"><a class="header" href="#bookmarks"><a href="01_usage/bookmarks">Bookmarks</a></a></h2>
<img src="01_usage/../images/bookmark_sign.png" width="100" height="100">
<p>Add bookmarks to mark and remember important log entries. Jump between bookmarks with shortcuts (<code>j</code> and <code>k</code>).</p>
<h2 id="commenting"><a class="header" href="#commenting"><a href="01_usage/commenting">Commenting</a></a></h2>
<img src="01_usage/../images/comment_sign.png" width="100" height="100">
<p>Comment line(s) of the log to have additional information about specific places in the file.</p>
<h2 id="charts"><a class="header" href="#charts"><a href="01_usage/charts">Charts</a></a></h2>
<p><img src="01_usage/../images/chart.png" alt="" /></p>
<p>To better understand what's going on in a large logfile, it can be helpful to visualize data over
time. <code>chipmunk</code> let's you define regular expressions that match a number and to use this expression
to capture a value throughout a logfile.</p>
<h2 id="concatenating-logfiles"><a class="header" href="#concatenating-logfiles"><a href="01_usage/concatenation">Concatenating logfiles</a></a></h2>
<img src="01_usage/../images/glue_together.png" width="100" height="100">
<p><code>chipmunk</code> can combine multiple log file. This is useful for example
when you just want to reassamble a logfile that were stored in parts.</p>
<h2 id="merging"><a class="header" href="#merging"><a href="01_usage/merging">Merging</a></a></h2>
<p><img src="01_usage/../images/intersection.png" alt="" /></p>
<p>Merging is useful if you have several log files e.g. from different
devices/processors and you want combine them by merging according to their
timestamps.</p>
<h2 id="time-ranges"><a class="header" href="#time-ranges"><a href="01_usage/time_range">Time Ranges</a></a></h2>
<img src="01_usage/../images/stopwatch_sign.png" width="100" height="100">
<p>To measure how much time passed between lines of a logfile <code>chipmunk</code> provides the <strong>Time Range</strong> Feature.</p>
<h2 id="dlt---diagnostic-log-and-trace"><a class="header" href="#dlt---diagnostic-log-and-trace"><a href="01_usage/dlt">DLT - Diagnostic Log and Trace</a></a></h2>
<img src="01_usage/../images/dlt.png" width="200" height="200">
<p>View and search and filter DLT files.
Programming in Rust!</p>
<h2 id="keyboard-shortcuts"><a class="header" href="#keyboard-shortcuts"><a href="01_usage/keyboard_shortcuts">Keyboard shortcuts</a></a></h2>
<img src="01_usage/../images/keyboard.png" width="100" height="100">
<p>An overview of all the keyboard shortcuts.</p>
<h2 id="command-line"><a class="header" href="#command-line"><a href="01_usage/command_line">Command line</a></a></h2>
<img src="01_usage/../images/command_line.png" width="100" height="100">
<p>It's also possible to open a file with <code>Chipmunk</code> directly from the console.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="searching-with-filters"><a class="header" href="#searching-with-filters">Searching with Filters</a></h1>
<p>Of course multiple searches are supported and search requests can be saved and restored as filters.</p>
<p><img src="01_usage/../images/multiple-filters.png" alt="" /></p>
<h2 id="search"><a class="header" href="#search">Search</a></h2>
<p>To search within the opened file, type into the area with the "Type a Search Request" placeholder and press <code>Enter</code>. The search results will be listed as they are with their whole line.</p>
<blockquote>
<p><strong>Note:</strong> The bottom left shows: Total lines of search results/Total lines of file</p>
</blockquote>
<h2 id="flags"><a class="header" href="#flags">Flags</a></h2>
<p>The three buttons on the right side of the search request input are flags to modify the search. Active flags will have a blue background color.</p>
<p><img src="01_usage/../images/Match_Case.png" alt="" /></p>
<p>Starting from the left, the first flag defines a <code>Case Sensitive</code>-search. As the name suggests, this flag will make the search case-sesitive when active.</p>
<p><img src="01_usage/../images/Match_Whole_Word.png" alt="" /></p>
<p>The second flag defines a <code>Match Whole Word</code>-search. With this flag active, the search only lists search results, where the search request matches with just special characters or spaces surrounding the word.</p>
<p><img src="01_usage/../images/Regex.png" alt="" /></p>
<p>The third flag defines a <code>Use Regular Expression</code>-search. With this flag active it is possible to run searches with Regex (Regular expression).</p>
<blockquote>
<p><strong>Note:</strong> It is possible to de-/activate search flags while and after starting the search.</p>
</blockquote>
<h2 id="create-filter"><a class="header" href="#create-filter">Create filter</a></h2>
<blockquote>
<p><strong>Note:</strong> Saved search requests will be called <strong>filter</strong> from this point on</p>
</blockquote>
<p>Type a search request at the bottom and click the floppy disc icon next to the search input.</p>
<blockquote>
<p><strong>Keyboard shortcut:</strong> <code>Enter + CTRL (Windows) / CMD (Mac/Linux)</code></p>
</blockquote>
<h2 id="edit-filter"><a class="header" href="#edit-filter">Edit filter</a></h2>
<p>Created filters can be modified afterwards by simply right-clicking on the desired filter and selecting <code>Edit</code>.</p>
<p>When the edit is done press <code>Enter</code> to apply the changes.</p>
<h2 id="remove-filter"><a class="header" href="#remove-filter">Remove filter</a></h2>
<p>Filters can be removed one by one by right-clicking on the filter and selecting <code>Remove</code>.</p>
<p>Another way is to drag&amp;drop the filter on the bin icon at the bottom of the sidebar which appears as soon as the filter is picked up and moved around.</p>
<p>To remove all created filters at once right-click on any filter and select <code>Remove all</code>.</p>
<p><img src="01_usage/../images/remove_filter.gif" alt="" /></p>
<h2 id="convert-into-chart"><a class="header" href="#convert-into-chart">Convert into chart</a></h2>
<p>If a filter needs to be converted into a chart, right-click on the filter and select <code>Convert To Chart</code>.</p>
<p>Another way to convert a filter into a chart is to drag&amp;drop the filter in the <strong>Charts</strong> section on the sidebar (only visible when at least one chart is already created).</p>
<blockquote>
<p><strong>Note:</strong> This option is only available for filters that consist of regular expressions.</p>
</blockquote>
<p><img src="01_usage/../images/convert_filter.gif" alt="" /></p>
<h2 id="create-time-range"><a class="header" href="#create-time-range">Create Time Range</a></h2>
<p>By selecting two or more filters time ranges can be created. To select multiple filters, hold <code>SHIFT</code> while left-clicking on the desired filters. After selecting the filters right-click on one of the selected filters and select <code>Create Time Range</code>.</p>
<blockquote>
<p><strong>Note:</strong> More about Time Range <a href="01_usage/searching_and_filtering.html#">here</a></p>
</blockquote>
<h2 id="en-disable-filter"><a class="header" href="#en-disable-filter">En-/Disable filter</a></h2>
<h3 id="in-search-results"><a class="header" href="#in-search-results">In search results</a></h3>
<p>Filters can be en-/disabled in the search results by un-/checking the checkbox next to the corresponding filter.</p>
<h3 id="in-search-results-and-output"><a class="header" href="#in-search-results-and-output">In search results and output</a></h3>
<p>Filters can also be en-/disabled completely by right-clicking the corresponding filter and select <code>Disable</code>.</p>
<p>If the disabled area is visible due to a filter or any other search component is disabled, the filter can be dragged and dropped into the area directly.</p>
<h2 id="save-and-load-filters"><a class="header" href="#save-and-load-filters">Save and load filters</a></h2>
<p>To save the created filters and other search settings click on the <code>Save</code> button in the <strong>Manage</strong> section on the sidebar.</p>
<p>To load previously created filters and other search settings click on the <code>Load</code> button in the <strong>Manage</strong> section on the sidebar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bookmarks-1"><a class="header" href="#bookmarks-1">Bookmarks</a></h1>
<p>Bookmarks can be used to pin down log entries that are important to the user.</p>
<p><img src="01_usage/../images/bookmarks.png" alt="bookmarks" /></p>
<p>Lines that are bookmarked will stick in the result view.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commenting-1"><a class="header" href="#commenting-1">Commenting</a></h1>
<p>There might be cases when you want to add a remark to a few places in the log. Simply mark lines, right-click and select <code>Comment</code> to add a comment to the specified lines.</p>
<blockquote>
<p><strong>NOTE:</strong> Commenting only works for the visible area at the start of marking lines. Scrolling out of the visible area while marking lines to comment is not supported.</p>
</blockquote>
<h3 id="reply-to-comments"><a class="header" href="#reply-to-comments">Reply to comments</a></h3>
<p>In addition to creating comment, you can also reply to comments with no limit.</p>
<h3 id="colors"><a class="header" href="#colors">Colors</a></h3>
<p>Comments can be grouped by color which can help when the view of comments is filtered by a specific color. The ordering of the comments is ascending by line numbers and can be changed to ordered by color (The order of the colors is predefined and cannot be edited).</p>
<p><img src="01_usage/../images/comment.gif" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="charts-1"><a class="header" href="#charts-1">Charts</a></h1>
<p>Getting a quick overview of what happened during a 24h-trace period can be daunting if the logfiles are huge (millions of log entries). A very neat way to get a quick overview is to show some graphs for what is happening.</p>
<p><img src="01_usage/../images/temperatures_chart.png" alt="" /></p>
<p>In this graph we captured processor workload for different cores. Any numerical value can be captured by using a regular expression with a group.</p>
<p>Supported are</p>
<ul>
<li>integers</li>
<li>floats</li>
</ul>
<p>An example for a regular expression with such a capture group looks like this:</p>
<p><code>measured:\s(\d+)</code></p>
<p>This will match <code>measured: 42</code> and pull out the value <code>42</code>.
Here is an example of how this looks in action.</p>
<p><img src="01_usage/../images/capture_expression.gif" alt="" /></p>
<h2 id="create-chart"><a class="header" href="#create-chart">Create chart</a></h2>
<p>Type a search request at the bottom and click the graph icon next to the search input.</p>
<blockquote>
<p><strong>Keyboard shortcut</strong>: <code>Shift + Enter</code></p>
</blockquote>
<h2 id="edit-chart"><a class="header" href="#edit-chart">Edit chart</a></h2>
<p>Created charts can be modified afterwards by simply right-clicking on the desired chart and selecting <code>Edit</code>.</p>
<p>When the edit is done press <code>Enter</code> to apply the changes.</p>
<h2 id="remove-chart"><a class="header" href="#remove-chart">Remove chart</a></h2>
<p>Charts can be removed one by one by right-clicking on the chart and selecting <code>Remove</code>.</p>
<p>Another way is to drag&amp;drop the chart on the bin icon at the bottom of the sidebar which appears as soon as the chart is picked up and moved around.</p>
<p>To remove all created charts at once right-click on any chart and select <code>Remove all</code>.</p>
<h2 id="convert-to-filter"><a class="header" href="#convert-to-filter">Convert to filter</a></h2>
<p>If a chart needs to be converted into a chart, right-click on the chart and select <code>Convert To Filter</code>.</p>
<p>Another way to convert a chart into a filter is to drag&amp;drop the chart in the <strong>Filters</strong> section on the sidebar.</p>
<h2 id="en-disable-chart"><a class="header" href="#en-disable-chart">En-/Disable chart</a></h2>
<h3 id="in-search-results-1"><a class="header" href="#in-search-results-1">In search results</a></h3>
<p>Charts can be en-/disabled in the search results by un-/checking the checkbox next to the corresponding chart.</p>
<h3 id="in-search-results-and-output-1"><a class="header" href="#in-search-results-and-output-1">In search results and output</a></h3>
<p>Charts can also be en-/disabled completely by right-clicking the corresponding chart and select <code>Disable</code>.</p>
<p>If the disabled area is visible due to a chart or any other search component is disabled, the chart can be dragged and dropped into the area directly.</p>
<h2 id="save-and-load-charts"><a class="header" href="#save-and-load-charts">Save and load charts</a></h2>
<p>To save the created charts and other search settings click on the <code>Save</code> button in the <strong>Manage</strong> section on the sidebar.</p>
<p>To load previously created charts and other search settings click on the <code>Load</code> button in the <strong>Manage</strong> section on the sidebar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assembling-files"><a class="header" href="#assembling-files">Assembling files</a></h1>
<p>There is handy support for combining multiple files into one view. You simple drag &amp; drop the files you need into a fresh tab. Then select the concatenate option.</p>
<p>Now you will have the chance to quickly check for a search expression to see if it is present in the dropped files. Here you can potentially include or exclude files.</p>
<img src="01_usage/../images/concat.gif" width="700" height="400">
<div style="break-before: page; page-break-before: always;"></div><h1 id="merging-1"><a class="header" href="#merging-1">Merging</a></h1>
<p>To help developers to deal with multiple logfiles, chipmunk can automatically detect timestamps and merge logs from multiple files sorting the lines of the files by their timestamp.</p>
<p>Here is an animation to show how it works:</p>
<p><img src="01_usage/../images/merging.gif" alt="" /></p>
<p>To merge files either drag and drop multiple files into the output window of <code>chipmunk</code></p>
<blockquote>
<p><strong>NOTE:</strong> It's possible to drag and drop additional files onto the dialog window.</p>
</blockquote>
<p>Another option is to open the <code>merging</code> tab on the sidebar and click on <code>Add file(s)</code>.</p>
<blockquote>
<p><strong>NOTE:</strong> You can select multiple files at once by clicking <code>Add file(s)</code></p>
</blockquote>
<p>Once the files are added, you have an overview of all added files and their filesize along with the detected datetime formats.</p>
<p>By left-clicking one of the files the details are being shown. The details display the content of the file along with the datetime format which colorizes the components to identify them easier in the content window.</p>
<p>The format can also be modfied by hand along with adding a year. Another option is to set the offset of a file after what time in <code>ms</code> the selected file should be included.</p>
<p>When the configuration and selection of the files is done, just press <code>Merge</code>.</p>
<blockquote>
<p><strong>NOTE:</strong> In the output window you can still see which line is from which file by the colors or hover with the mouse over them which will show the filename.</p>
</blockquote>
<p><img src="01_usage/../images/merging_sample.gif" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-range"><a class="header" href="#time-range">Time Range</a></h1>
<p><code>Chipmunk</code> provides the measurement of  time that passed between lines and makes it possible to compare them in a chart.</p>
<h2 id="create-and-remove-time-ranges"><a class="header" href="#create-and-remove-time-ranges">Create and remove time ranges</a></h2>
<h3 id="start-time-range"><a class="header" href="#start-time-range">Start time range</a></h3>
<p>By right-clicking on a line either select the option <code>Open time measurement view</code> or when it already is open <code>Start Time Range</code>.</p>
<h3 id="add-time-range"><a class="header" href="#add-time-range">Add time range</a></h3>
<p>If you want to another time range to the current selection right-click and select <code>Add time range &lt;line begin&gt;-&lt;line end&gt;</code>.</p>
<h3 id="close-time-range"><a class="header" href="#close-time-range">Close time range</a></h3>
<p>The currently opened time range can be closed by right-clicking and selecting <code>Close time range &lt;line begin&gt;-&lt;line end&gt;</code>.</p>
<h3 id="remove-time-range"><a class="header" href="#remove-time-range">Remove time range</a></h3>
<p>Time ranges can easily be removed by right-clicking on a line which is part of a time range select:</p>
<ul>
<li>Remove a single range: <code>Remove this range</code></li>
<li>Remove all <strong>except the selected range</strong>: <code>Remove all except selected</code></li>
<li>Remove all: <code>Remove all ranges</code></li>
</ul>
<p><img src="01_usage/../images/time_range.gif" alt="" /></p>
<h2 id="analyze-time-ranges"><a class="header" href="#analyze-time-ranges">Analyze time ranges</a></h2>
<p>In the tabs below select <code>Time Measurement</code> to see all of the created ranges.</p>
<p>On the bottom left the format to detect timestamps is shown.
On the bottom right the <code>...</code> symbol offers options to add, remove and set default timestamp formats.</p>
<h3 id="view-modes"><a class="header" href="#view-modes">View modes</a></h3>
<p>There are two modes available on viewing the charts:</p>
<ol>
<li><code>Scaled</code> (default)</li>
</ol>
<p>Sorts the ranges by their position in the logfile and lets you scale on the ranges.</p>
<p>Scrolling inside the scaler changes the scaling of the view. By holding left-mouse in the <strong>upper part</strong> of the scaler, the scaler can be moved to view specific parts of the created ranges. By holding left-mouse in the <strong>lower part</strong> of the scaler, the scaler size can be change to that specific part and that marked size.</p>
<ol start="2">
<li><code>Aligned</code></li>
</ol>
<p>Aligns all ranges to the left and sorts ranges by their position in the logfile.</p>
<blockquote>
<p>NOTE: To change the view mode right-click anywhere in the <code>Time Measurement</code> area and select <code>Switch to: ...</code></p>
</blockquote>
<p><img src="01_usage/../images/time_measurement.gif" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dlt-support"><a class="header" href="#dlt-support">DLT support</a></h1>
<p>The Diagnostic Log and Trace AUTOSAR format is widely used in the automotive industry and is a binary log format. <code>chipmunk</code> can understand and process DLT content in large quantities.</p>
<p><img src="01_usage/../images/dlt-support.png" alt="" /></p>
<h2 id="import-file"><a class="header" href="#import-file">Import file</a></h2>
<p>When opening a dlt file, you are prompted with this dialog. Here you can also provide the path to a <strong>FIBEX</strong> file that contains descriptions for you non-verbose messages.</p>
<blockquote>
<p><strong>NOTE:</strong> Referred Fibex files will be restored for each file it was referred to</p>
</blockquote>
<p>This can be expanded so can select what components or loglevels you want to include. Note that you are presented with a statistics of how many log messages exist e.g. for a component with a certain log level.</p>
<p><img src="01_usage/../images/import_dlt.gif" alt="" /></p>
<p>The columns can be configured by right-clicking in one of the column titles or hover over one of the column titles and left-click the <code>...</code>. Then you can filter out columns and adjust colors.</p>
<p><img src="01_usage/../images/dlt_columns.gif" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard-shortcuts-1"><a class="header" href="#keyboard-shortcuts-1">Keyboard Shortcuts</a></h1>
<p>Important to most developers: a good and intuitive set of keyboard shortcuts.</p>
<p><img src="01_usage/../images/shortcuts.png" alt="" /></p>
<p>Just hit <code>?</code> and you should get the overview documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-1"><a class="header" href="#command-line-1">Command Line</a></h1>
<p>Here's a way to open a file with <code>Chipmunk</code> directly from the command line.</p>
<p>Run Chipmunk and open the <code>File</code> section of the toolbar at the top and install <code>cm</code>.</p>
<blockquote>
<p><strong>NOTE:</strong> This only needs to be done once</p>
</blockquote>
<p><img src="01_usage/../images/cm.png" alt="" /></p>
<p><strong>Now you're ready to go!</strong></p>
<p>Simply open the command line of your choice and type:</p>
<p><code>cm [...filename]</code></p>
<blockquote>
<p><strong>NOTE:</strong> Opening with multiple files will result in one tab for each file</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" type="text/css" href="../styles/styles.extension.css">
<h1 id="extending-chipmunk-with-plugins"><a class="header" href="#extending-chipmunk-with-plugins">Extending Chipmunk with plugins</a></h1>
<p>In this section everything about plugins will be explained as well as how to create custom plugins for <strong>Chipmunk</strong>.</p>
<h2 id="about-plugins"><a class="header" href="#about-plugins">About plugins</a></h2>
<p>In computing, a plug-in (or plugin, add-in, addin, add-on, or addon) is a software component that adds a specific feature to an existing computer program. When a program supports plug-ins, it enables customization.<sup>[1]</sup></p>
<p>Plugins in <strong>Chipmunk</strong> extend the default functionalities making it possible to receive and analyze data from different kind of sources (e.g. serial connections).</p>
<h2 id="plugin-structure"><a class="header" href="#plugin-structure">Plugin structure</a></h2>
<p><strong>Chipmunk</strong> plugins mainly consist of a <strong>render</strong> and a <strong>process</strong> part.</p>
<h3 id="render"><a class="header" href="#render">Render</a></h3>
<p>The render part is responsible for the visual part of the plugin itself. With the help of Angular components are created using Typescript, HTML and CSS. The component will be automatically included in <strong>Chipmunk</strong> after building the plugin.</p>
<h3 id="process"><a class="header" href="#process">Process</a></h3>
<p>The process part is responsible for the background processing of the plugin and modifying the output stream.</p>
<h2 id="chipmunk-store"><a class="header" href="#chipmunk-store">Chipmunk Store</a></h2>
<p>The <strong>Chipmunk Store</strong> provides different plugins to install on <strong>Chipmunk</strong>. By simply clicking on the desired plugin and then on <em>install</em> will add the plugin to <strong>Chipmunk</strong>. The <strong>Chipmunk Store</strong> also provides the option to upgrade the already installed plugin to a newer version.</p>
<img src="02_extensions/../images/chipmunk_store.png"/>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<hr/>
<sup>[1]</sup> https://en.wikipedia.org/wiki/Plug-in_(computing)<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" type="text/css" href="../styles/styles.extension.css">
<h1 id="create-a-plugin"><a class="header" href="#create-a-plugin">Create a plugin</a></h1>
<p>This section provides a step by step guide on how to get <strong>Chipmunk</strong> and the <strong>Quickstart</strong> repository as well as how to build them.
The repository <strong>Quickstart</strong> provides a variety of plugins which can be copied and modifed to create new plugins.</p>
<h2 id="installation-of-plugins-and-chipmunk"><a class="header" href="#installation-of-plugins-and-chipmunk">Installation of plugins and Chipmunk</a></h2>
<p>First off clone the create a folder for <strong>Chipmunk</strong> and <strong>Quickstart</strong> by typing the following commands:</p>
<pre><code>mkdir chipmunk-developing
cd chipmunk-developing
</code></pre>
<p>After creating the folder, clone both the <strong>Chipmunk</strong> and the <strong>Quickstart</strong> repository into the folder and navigate into it.</p>
<pre><code>git clone https://github.com/esrlabs/chipmunk.git
git clone https://github.com/esrlabs/chipmunk-quickstart.git
cd chipmunk-quickstart
</code></pre>
<p>The <strong>Quickstart</strong> repository has a few examples of plugins which are located in the folder <code>plugin</code>:</p>
<pre><code>&#9492;&#9472;&#9472; plugins
    &#9500;&#9472;&#9472; plugin.helloworld
    &#9500;&#9472;&#9472; plugin.row.columns
    &#9500;&#9472;&#9472; plugin.row.parser
    &#9500;&#9472;&#9472; plugin.selection.parser
    &#9492;&#9472;&#9472; plugin.sh
</code></pre>
<p>To build the plugin, type the following command with the path to the target plugin:</p>
<pre><code>rake build[./plugins/plugin.helloworld]</code></pre>
<p>Optionally you can define a version of your plugin:</p>
<pre><code>rake build[./plugins/plugin.helloworld, 1.0.1]</code></pre>
<blockquote>
<p><strong>WINDOWS</strong> Note: To call a rake task with multiple arguments, it could be command should be wrapped as string <code>rake 'build[./plugins/plugin.helloworld, 1.0.1]'</code></p>
</blockquote>
<blockquote>
<p>Note: The very first build always takes some noticeable time because of build script downloads and compiles necessary infrastructure.</p>
</blockquote>
<p>As a result the folder <code>releases</code> will be created with the compiled plugin:</p>
<pre><code>&#9500;&#9472;&#9472; plugins
&#9474    &#9500;&#9472;&#9472; plugin.helloworld
&#9474    &#9500;&#9472;&#9472; plugin.row.columns
&#9474    &#9500;&#9472;&#9472; plugin.row.parser
&#9474    &#9500;&#9472;&#9472; plugin.selection.parser
&#9474    &#9492;&#9472;&#9472; plugin.sh
&#9492;&#9472;&#9472; releases
     &#9492;&#9472;&#9472; plugin.helloworld
</code></pre>
<p>To build <strong>Chipmunk</strong> run the following commands to navigate into the folder where the repository was copied:</p>
<pre><code>rake full_pipeline</code></pre>
<p>The building of <strong>Chipmunk</strong> will take some time but only needs to be built once. After the build is finished <strong>Chipmunk</strong> can be executed from the <code>releases</code> folder.</p>
<p>Before starting <strong>Chipmunk</strong> some environment variables need to be passed in as a preparation.</p>
<p>First off define a full path to the folder that will hold the release of your plugin.</p>
<p><code><pre>export CHIPMUNK_PLUGINS_SANDBOX=../chipmunk-quickstart/releases</pre></code></p>
<p>By default <strong>Chipmunk</strong> stores plugins the home folder in <code>.chipmunk/plugins</code> but by running the command above it can be modified.</p>
<p>To prevent the installation of default plugins, run the following command</p>
<pre><code>export CHIPMUNK_PLUGINS_NO_DEFAULTS=true</code></pre>
<p>If your has plugin already been published in the <strong>Chipmunk Store</strong> these commands would prevent it from updating:</p>
<pre><code>export CHIPMUNK_PLUGINS_NO_UPGRADE=true
export CHIPMUNK_PLUGINS_NO_UPDATES=true
</code></pre>
<p>To enable logs in the Console making it easier to debug:</p>
<pre><code>export CHIPMUNK_DEV_LOGLEVEL=ENV</code></pre>
<p>Now <strong>Chipmunk</strong> is ready to be executed.</p>
<h2 id="rake-commands"><a class="header" href="#rake-commands">Rake commands</a></h2>
<p>The following Rake commands are vital for the compilation of <strong>Chipmunk</strong>, which is why in this section the most important rake commands are going to be mentioned and described.</p>
<pre><code>rake start                                          # Start Chipmunk
rake full_pipeline                                  # Build Chipmunk (whole application)
rake build[./plugins/plugin.helloworld]             # Build plugin
rake build[./plugins/plugin.helloworld, 1.0.1]      # Build plugin with version
rake 'build[./plugins/plugin.helloworld, 1.0.1]'    # Build plugin with version (Windows) 
</code></pre>
<p>If a new update of <strong>Chipmunk</strong> is available, first run <code>rake clobber</code> (to remove all compiled files) and then <code>rake full_pipeline</code> to update and re-build <strong>Chipmunk</strong>.</p>
<p>The next section gives a thorough explanation of the default plugins provided by <strong>Quickstart</strong></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" type="text/css" href="../styles/styles.extension.css">
<script src="../scripts/script.tab.js">
</script>
<h1 id="default-plugins"><a class="header" href="#default-plugins">Default plugins</a></h1>
<p>In the first part of this section all default plugins provided by <strong>Quickstart</strong> will be thoroughly explained as of what they do and explain each line. In the second part other useful things such as popup windows or notifications will demonstrated with examples.</p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>The plugin <strong>Hello World</strong> creates a button which prints 'Hello World!' in the debug console whenever it is clicked.</p>
<pre><code>&#9500;&#9472;&#9472; process
&#9474;   &#9500;&#9472;&#9472; src
&#9474;   &#9474;   &#9492;&#9472;&#9472; main.ts
&#9474;   &#9500;&#9472;&#9472; package.json
&#9474;   &#9492;&#9472;&#9472; tsconfig.json
&#9492;&#9472;&#9472; render
    &#9500;&#9472;&#9472; src
    &#9474;   &#9500;&#9472;&#9472; lib
    &#9474;   &#9474;   &#9500;&#9472;&#9472; views
    &#9474;   &#9474;   &#9474;    &#9492;&#9472;&#9472; sidebar.vertical
    &#9474;   &#9474;   &#9474;        &#9500;&#9472;&#9472; compontent.ts
    &#9474;   &#9474;   &#9474;        &#9500;&#9472;&#9472; styles.less
    &#9474;   &#9474;   &#9474;        &#9492;&#9472;&#9472; template.html
    &#9474;   &#9474;   &#9500;&#9472;&#9472; module.ts
    &#9474;   &#9474;   &#9492;&#9472;&#9472; service.ts
    &#9474;   &#9492;&#9472;&#9472; public-api.ts
    &#9500;&#9472;&#9472; ng-package.json
    &#9500;&#9472;&#9472; package.json
    &#9500;&#9472;&#9472; tsconfig.json
    &#9500;&#9472;&#9472; tsconfig.spec.json
    &#9492;&#9472;&#9472; tslint.json
</code></pre>
<div class="tab ang">
  <button class="tablinks" onclick="openCode(event, 'ang_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'ang_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'ang_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'ang_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'ang_public_api.ts')">public_api.ts</button>
</div>
<div id="ang_template.html" class="tabcontent ang">
<pre><code class="language-HTML">&lt;p&gt;Example&lt;/p&gt;
&lt;button (click)=&quot;_ng_click()&quot;&gt;&lt;/button&gt;   &lt;!-- Create a button which calls _ng_click from the components.ts file --&gt;
</code></pre>
</div>
<div id="ang_styles.less" class="tabcontent ang">
<pre><code class="language-CSS">p {
    color: #FFFFFF;
}
button {
    height: 20px;
    width: 50px;
}
</code></pre>
</div>
<div id="ang_component.ts" class="tabcontent ang active">
<pre><code class="language-Javascript">import { Component } from '@angular/core';  // Import the Angular component that is necessary for the setup below
@Component({
    selector: 'example',                    // Choose the selector name of the plugin
    templateUrl: './template.html',         // Assign HTML file as template
    styleUrls: ['./styles.less']            // Assign LESS file as style sheet file
})
export class ExampleComponent {             // Create an example class for the method
    public _ng_click() {                    // Create a method for the button in template.html
        console.log('Hello World!');        // Initiate a console output
    }
}
</code></pre>
</div>
<div id="ang_module.ts" class="tabcontent ang">
<pre><code class="language-Javascript">import { NgModule } from '@angular/core';                   // Import the Angular component that is necessary for the setup below
import { Example } from './component';                      // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';         // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ Example ],                              // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                           // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ Example ]                                    // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {  // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');       // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="ang_public_api.ts" class="tabcontent ang">
<pre><code class="language-Javascript">export * from './lib/component';    // Export the main component of the plugin
export * from './lib/module';       // Export the module file of the plugin
</code></pre>
</div>
<blockquote>
<p><strong>IMPORTANT</strong>: Make sure the <code>PluginModule</code> class inherits from <code>Toolkit.PluginNgModule</code> or else the modules won't be part of the plugin!</p>
</blockquote>
<blockquote>
<p><strong>IMPORTANT</strong>: Exporting the component and module is required by Angular and necessary for the plugin to work!</p>
</blockquote>
<h2 id="row-columns"><a class="header" href="#row-columns">Row Columns</a></h2>
<p>The plugin <strong>Row Columns</strong> creates a custom render for CSV files to show its conent in columns.</p>
<pre><code>&#9492;&#9472;&#9472; render
    &#9500;&#9472;&#9472; src
    &#9474;   &#9500;&#9472;&#9472; lib
    &#9474;   &#9474;   &#9500;&#9472;&#9472; row.columns.api.ts
    &#9474;   &#9474;   &#9492;&#9472;&#9472; row.columns.api.ts
    &#9474;   &#9492;&#9472;&#9472; public-api.ts
    &#9500;&#9472;&#9472; ng-package.json
    &#9500;&#9472;&#9472; package.json
    &#9500;&#9472;&#9472; tsconfig.json
    &#9500;&#9472;&#9472; tsconfig.spec.json
    &#9492;&#9472;&#9472; tslint.json
</code></pre>
<div class="tab col">
  <button class="tablinks" onclick="openCode(event, 'col_row.columns.api.ts')">row.columns.api.ts</button>
  <button class="tablinks active" onclick="openCode(event, 'col_row.columns.ts')">row.columns.ts</button>
  <button class="tablinks" onclick="openCode(event, 'col_public_api.ts')">public_api.ts</button>
</div>
<div id="col_row.columns.api.ts" class="tabcontent col">
<pre><code class="language-Javascript">import * as Toolkit from 'chipmunk.client.toolkit';
// Delimiter for CSV files.
export const CDelimiters = [';', ',', '\t'];
// For now chipmunk supports only predefined count of columns. Developer cannot change 
// it dynamically. Here we are defining some columns headers
export const CColumnsHeaders = [
    'A',
    'B',
    'C',
    'D',
    'F',
    'G',
    'H',
    'I',
    'J',
    'K',
];
let delimiter: string | undefined;
/**
 * @class ColumnsAPI
 * @description Implementation of custom row's render, based on TypedRowRenderAPIColumns
 */
export class ColumnsAPI extends Toolkit.TypedRowRenderAPIColumns {
    constructor() {
        super();
    }
    /**
     * Returns list of column's headers
     * @returns { string[] } - column's headers
     */
    public getHeaders(): string[] {
        return CColumnsHeaders;
    }
    /**
     * Should returns parsed row value as array of columns. Length of columns here
     * should be equal to length of columns (see getHeaders)
     * @param str { string } - string value of row
     * @returns { string[] } - values of columns for row
     */
    public getColumns(str: string): string[] {
        const columns: string[] = str.split(this._getDelimiter(str));
        // Because we don't know, how much columns file will have, we are adding missed
        // or removing no needed columns
        if (columns.length < CColumnsHeaders.length) {
            for (let i = CColumnsHeaders.length - columns.length; i >= 0; i += 1) {
                columns.push('-');
            }
        } else if (columns.length > CColumnsHeaders.length) {
            const rest: string[] = columns.slice(CColumnsHeaders.length - 2, columns.length);
            columns.push(rest.join(this._getDelimiter(str)));
        }
        return columns;
    }
    /**
     * This method will be called by chipmunk's core once before render column's headers.
     * @returns { Array<{ width: number, min: number }> } - default width and minimal width for
     * each column
     */
    public getDefaultWidths(): Array<{ width: number, min: number }> {
        return [
            { width: 50, min: 30 },
            { width: 50, min: 30 },
            { width: 50, min: 30 },
            { width: 50, min: 30 },
            { width: 50, min: 30 },
            { width: 50, min: 30 },
            { width: 50, min: 30 },
            { width: 50, min: 30 },
            { width: 50, min: 30 },
            { width: 50, min: 30 },
        ];
    }
    private _getDelimiter(input: string): string {
        if (delimiter !== undefined) {
            return delimiter;
        } else {
            let score: number = 0;
            CDelimiters.forEach((del: string) => {
                let length = input.split(del).length;
                if (length > score) {
                    score = length;
                    delimiter = del;
                }
            });    
        }
        return delimiter;        
    }
}
</code></pre>
</div>
<div id="col_row.columns.ts" class="tabcontent col active">
<pre><code class="language-Javascript">import * as Toolkit from 'chipmunk.client.toolkit';
import { ColumnsAPI } from './row.columns.api';
/**
 * @class Columns
 * @description Chipmunk supports custom renders for rows. It means, before row 
 * (in main view and view of search result) will be show, chipmunk will apply 
 * available custom renders. Render could be bound with type of income data. 
 * For example with type of opened file.
 * To bind render with type of income data developer should use abstract class
 * TypedRowRender. As generic class, developer should provide render, which
 * should be used for such data. 
 * In this example we are using predefined render of columns
 */
export class Columns extends Toolkit.TypedRowRender<ColumnsAPI> {
    // Store instance of custom render to avoid recreating of it with each new
    // chipmunk's core request
    private _api: ColumnsAPI = new ColumnsAPI();
    constructor() {
        super();
    }
    /**
     * This method will be called by chipmunk to detect, which kind of render we are
     * going to use.
     * @returns { ETypedRowRenders } - tells chipmunk's core, which kind of render will be used
     */
    public getType(): Toolkit.ETypedRowRenders {
        // We will use columns render.
        return Toolkit.ETypedRowRenders.columns;
    }
    /**
     * This method will be called for each row in main view and view of search results
     * @param sourceName { string } - name of source of incoming data. For example for file
     * it will be filename. For plugin - plugin name.
     * @param sourceMeta { string } - optional data, which could better describe incoming data.
     * For example for text file it will be "plain/text"; for DLT file - "dlt"
     * @returns { boolean } - in "true" custom render will be applied for row; in "false" custom
     * render will be ignored
     */
    public isTypeMatch(sourceName: string, sourceMeta?: string): boolean {
        // In this example, we are creating custom render for CSV file, to show its content
        // as columns.
        // So, let's just check file name for expected extension.
        return sourceName.search(/\.csv$/gi) !== -1;
    }
    /**
     * Caller for API of custom render. Would be called by chipmunk's core for each row, which returns
     * "true" via "isTypeMatch"
     * @returns { Class }
     */
    public getAPI(): ColumnsAPI {
        return this._api;
    }
}
</code></pre>
</div>
<div id="col_public_api.ts" class="tabcontent col">
<pre><code class="language-Javascript">/*
 * Public API Surface of terminal
 */
import { Columns } from './lib/row.columns';
const columns = new Columns();
// For Angular based plugin would be enough to make export with instance of
// render. No needs to use gateway
export { columns };
</code></pre>
</div>
<h2 id="row-parser"><a class="header" href="#row-parser">Row Parser</a></h2>
<p>The plugin <strong>Row Parser</strong> creates a custom render for DLT files to colorize keywords.</p>
<pre><code>&#9492;&#9472;&#9472; render
    &#9500;&#9472;&#9472; src
    &#9474;   &#9492;&#9472;&#9472; index.ts
    &#9500;&#9472;&#9472; package.json
    &#9500;&#9472;&#9472; tsconfig.json
    &#9500;&#9472;&#9472; tslint.json
    &#9492;&#9472;&#9472; webpack.config.js
</code></pre>
<div class="tab par">
  <button class="tablinks active" onclick="openCode(event, 'par_index.ts')">index.ts</button>
</div>
<div id="par_index.ts" class="tabcontent par active">
<pre><code class="language-Javascript">import * as Toolkit from 'chipmunk.client.toolkit';
import { default as AnsiUp } from 'ansi_up';
const ansiup = new AnsiUp();
ansiup.escape_for_html = false;
const REGS = {
    COLORS: /\x1b\[[\d;]{1,}[mG]/,
    COLORS_GLOBAL: /\x1b\[[\d;]{1,}[mG]/g,
};
const ignoreList: { [key: string]: boolean } = {};
// To create selection parse we should extend class from RowCommonParser class
// Our class should have at least one public methods:
// - parse(str: string, themeTypeRef: Toolkit.EThemeType, row: Toolkit.IRowInfo)
export class ASCIIColorsParser extends Toolkit.RowCommonParser {
    /**
     * Method with be called by chipmunk for each row in main view and search results view.
     * @param str { string } - row value as string
     * @param themeTypeRef { EThemeType } - name of current color theme
     * @param row { IRowInfo } - information about row
     * @returns { string } - parsed row as string. It can include HTML tags
     */
    public parse(str: string, themeTypeRef: Toolkit.EThemeType, row: Toolkit.IRowInfo): string {
        if (typeof row.sourceName === "string") {
            if (ignoreList[row.sourceName] === undefined) {
                ignoreList[row.sourceName] = row.sourceName.search(/\.dlt$/gi) !== -1;
            }
            if (!ignoreList[row.sourceName]) {
                if (row.hasOwnStyles) {
                    // Only strip ANSI escape-codes
                    return str.replace(REGS.COLORS_GLOBAL, "");
                } else if (REGS.COLORS.test(str)) {
                    // ANSI escape-codes to html color-styles
                    return ansiup.ansi_to_html(str);
                }
            }
        }
        return str;
    }
}
// To delivery plugin into chipmunk we should use chipmunk's gateway
// It's stored in global variable "chipmunk"
// Gateway has a method "setPluginExports". With this method we can
// define a list of exported parsers.
const gate: Toolkit.PluginServiceGate | undefined = (window as any).logviewer;
if (gate === undefined) {
    console.error(`Fail to find chipmunk gate.`);
} else {
    gate.setPluginExports({
        // Name of property (in this case it's "ascii" could be any. Chipmunk doesn't check
        // a name of property, but detecting a parent class.
        ascii: new ASCIIColorsParser(),
    });
}
</code></pre>
</div>
<h2 id="selection-parser"><a class="header" href="#selection-parser">Selection Parser</a></h2>
<p>The plugin <strong>Selection Parser</strong> creates a parser that parses the selected string in the output console. The parser can be selected by right-clicking and opening the option menu.</p>
<pre><code>&#9492;&#9472;&#9472; render
    &#9500;&#9472;&#9472; src
    &#9474;   &#9492;&#9472;&#9472; index.ts
    &#9500;&#9472;&#9472; package.json
    &#9500;&#9472;&#9472; tsconfig.json
    &#9500;&#9472;&#9472; tslint.json
    &#9492;&#9472;&#9472; webpack.config.js
</code></pre>
<div class="tab sel">
  <button class="tablinks active" onclick="openCode(event, 'sel_index.ts')">index.ts</button>
</div>
<div id="sel_index.ts" class="tabcontent sel active">
<pre><code class="language-Javascript">import * as Toolkit from 'chipmunk.client.toolkit';
// To create selection parse we should extend class from SelectionParser class
// Our class should have at least two public methods:
// - getParserName(selection: string): string | undefined
// - parse(selection: string, themeTypeRef: Toolkit.EThemeType)
export class SelectionParser extends Toolkit.SelectionParser {
    /**
     * Method with be called by chipmunk before show context menu in main view.
     * If selection acceptable by parser, method should return name on menu item
     * in context menu of chipmunk.
     * If selection couldn't be parsered, method should return undefined. In this
     * case menu item in context menu for this parser will not be show.
     * @param selection { string } - selected text in main view of chipmunk
     * @returns { string } - name of menu item in context menu
     * @returns { undefined } - in case if menu item should not be shown in context menu
     */
    public getParserName(selection: string): string | undefined {
        const date: Date | undefined = this._getDate(selection);
        return date instanceof Date ? 'Convert to DateTime' : undefined;
    }
    /**
     * Method with be called by chipmunk if user will select menu item (see getParserName)
     * in context menu of selection in main view.
     * @param selection { string } - selected text in main view of chipmunk
     * @param themeTypeRef { EThemeType } - name of current color theme
     * @returns { string } - parsed string
     */
    public parse(selection: string, themeTypeRef: Toolkit.EThemeType): string {
        const date: Date | undefined = this._getDate(selection);
        return date !== undefined ? date.toUTCString() : '';
    }
    private _getDate(selection: string): Date | undefined {
        const num: number = parseInt(selection, 10);
        if (!isFinite(num) || isNaN(num)) {
            return undefined;
        }
        const date: Date = new Date(num);
        return date instanceof Date ? date : undefined;
    }
}
// To delivery plugin into chipmunk we should use chipmunk's gateway
// It's stored in global variable "chipmunk"
// Gateway has a method "setPluginExports". With this method we can
// define a list of exported parsers.
const gate: Toolkit.PluginServiceGate | undefined = (window as any).chipmunk;
if (gate === undefined) {
    // This situation isn't possible, but let's check it also
    console.error(`Fail to find chipmunk gate.`);
} else {
    gate.setPluginExports({
        // Name of property (in this case it's "datetime" could be any. Chipmunk doesn't check
        // a name of property, but detecting a parent class.
        datetime: new SelectionParser(),
    });
}
</code></pre>
</div>
<h2 id="plugin-with-settings"><a class="header" href="#plugin-with-settings">Plugin with Settings</a></h2>
<p>The plugin <strong>Plugin with Settings</strong> gives the opportunity to create custom settings for plugins.</p>
<p>At the top there is an input area to search for specific settings quickly. On the left side are the sections of the settings.</p>
<p>To create settings the first step is to create the component for the setting. In this example <code>SomestringSetting</code> will create an input field which takes a string in.
Currently there are 3 types of settings available to implement: <strong>string input, number input and checkboxes</strong></p>
<p>The <code>validate</code> method to checks the value of the setting and only saves if it is valid.</p>
<p>The <code>Service</code> class is necessary to register the created settings and make them accessable. The <code>setup</code> registers the created settings with:
<code>key</code>   -   Keyname of setting (necessary to define subsettings)
<code>path</code>  -   Keyname of supersetting (under which section the settings should be put)
<code>name</code>  -   Title of setting (e.g. title of input)
<code>desc</code>  -   Description under setting
<code>type</code>  -   Type of setting (standard - show settings, advanced - button to show/hide advanced settings)</p>
<p>By creating a <code>read</code> method the value of the setting can be read and put out into the console.
It's important to note, that the <code>get</code> method needs the data type of the setting and takes the relative path of the setting (e.g. <em>'selectionparser'</em>) and the full path <strong>(all superpathes seperated by a '.')</strong> as the second arguement (e.g. <em>'plugins.selectionparser'</em>).</p>
<p>Settings can be created for both the UI part or the process part of the plugin. Settings for the UI part are located in the <code>render</code> folder, whereas the settings for the process part are located in the <code>process</code> folder.</p>
<blockquote>
<p>NOTE: Settings can only be added under <strong>Plugins</strong></p>
</blockquote>
<blockquote>
<p>NOTE: No restriction on amount of sub-settings</p>
</blockquote>
<pre><code>&#9492;&#9472;&#9472; process
    &#9500;&#9472;&#9472; src
    &#9474;   &#9492;&#9472;&#9472; main.ts
    &#9500;&#9472;&#9472; package.json
    &#9492;&#9472;&#9472; tsconfig.json
&#9492;&#9472;&#9472; render
    &#9500;&#9472;&#9472; src
    &#9474;   &#9492;&#9472;&#9472; index.ts
    &#9500;&#9472;&#9472; package.json
    &#9500;&#9472;&#9472; tsconfig.json
    &#9500;&#9472;&#9472; tslint.json
    &#9492;&#9472;&#9472; webpack.config.js
</code></pre>
<div class="tab pws">
  <button class="tablinks active" onclick="openCode(event, 'pws_main.ts')">main.ts</button>
  <button class="tablinks" onclick="openCode(event, 'pws_index.ts')">index.ts</button>
</div>
<div id="pws_main.ts" class="tabcontent pws active">
<pre><code class="language-Javascript">import PluginIPCService, { ServiceState, ServiceSettings, Entry, ESettingType, IPCMessages, Field, ElementInputStringRef } from 'chipmunk.plugin.ipc';
/**
 * To create settings field we should use abstract class Field<T>.
 * T: string, boolean or number
 */
export class SomestringSetting extends Field<string> {
    /**
     * We should define reference to one of controller to render setting:
     */
    private _element: ElementInputStringRef = new ElementInputStringRef({
        placeholder: 'Test placeholder',
    });
    /**
     * Returns default value
     */
    public getDefault(): Promise<string> {
        return new Promise((resolve) => {
            resolve('');
        });
    }
    /**
     * Validation of value. Called each time user change it. Also called before save data into
     * setting file.
     * Should reject on error and resolve on success.
     */
    public validate(state: string): Promise<void> {
        return new Promise((resolve, reject) => {
            if (typeof state !== 'string') {
                return reject(new Error(`Expecting string type for "SomestringSetting"`));
            }
            if (state.trim() !== '' && (state.length < 5 || state.length > 15)) {
                return reject(new Error(`${state.length} isn't valid length. Expected 5 < > 15`));
            }
            resolve();
        });
    }
    /**
     * Should return reference to render component
     */
    public getElement(): ElementInputStringRef {
        return this._element;
    }
}
class Plugin {
    constructor() {
        this._setup();
        this._read();
    }
    private _setup() {
        // Create a group (section) for settings
        ServiceSettings.register(new Entry({
            key: 'testBEEntry',
            path: '', // Put settings into root of settings tree
            name: 'Backend Plugin Settings',
            desc: 'This is some kind of settings, delivered from backend',
            type: ESettingType.standard,
        })).then(() => {
            console.log(`Group is registred`);
            ServiceSettings.register(new SomestringSetting({
                key: 'pluginBESetting',
                path: 'testBEEntry',
                name: 'BE String setting',
                desc: 'This is test of string setting',
                type: ESettingType.standard,
                value: '',
            })).then(() => {
                console.log(`Setting is registred`);
            }).catch((error: Error) => {
                console.log(`Fail due: ${error.message}`);
            });
        }).catch((error: Error) => {
            console.log(`Fail due: ${error.message}`);
        });
    }
    private _read() {
        // Read some settings
        ServiceSettings.get<boolean>('PluginsUpdates', 'general.plugins').then((value: boolean) => {
            console.log(value);
        }).catch((error: Error) => {
            console.log(error);
        });
    }
}
const app: Plugin = new Plugin();
// Notify core about plugin
ServiceState.accept().catch((err: Error) => {
    console.log(`Fail to notify core about plugin due error: ${err.message}`);
});
</code></pre>
</div>
<div id="pws_index.ts" class="tabcontent pws">
<pre><code class="language-Javascript">// tslint:disable: max-classes-per-file
import * as Toolkit from 'chipmunk.client.toolkit';
import { Field, ElementInputStringRef } from 'chipmunk.client.toolkit';
/**
 * To create settings field we should use abstract class Field<T>.
 * T: string, boolean or number
 */
export class SomestringSetting extends Field<string> {
    /**
     * We should define reference to one of controller to render setting:
     */
    private _element: ElementInputStringRef = new ElementInputStringRef({
        placeholder: 'Test placeholder',
    });
    /**
     * Returns default value
     */
    public getDefault(): Promise<string> {
        return new Promise((resolve) => {
            resolve('');
        });
    }
    /**
     * Validation of value. Called each time user change it. Also called before save data into
     * setting file.
     * Should reject on error and resolve on success.
     */
    public validate(state: string): Promise<void> {
        return new Promise((resolve, reject) => {
            if (typeof state !== 'string') {
                return reject(new Error(`Expecting string type for "SomestringSetting"`));
            }
            if (state.trim() !== '' && (state.length < 3 || state.length > 10)) {
                return reject(new Error(`${state.length} isn't valid length. Expected 3 < > 10`));
            }
            resolve();
        });
    }
    /**
     * Should return reference to render component
     */
    public getElement(): ElementInputStringRef {
        return this._element;
    }
}
/**
 * Create service (to have access to chipmunk API)
 */
class Service extends Toolkit.APluginService {
    constructor() {
        super();
        // Listen moment when API will be available
        this.onAPIReady.subscribe(() => {
            this.read();
            this.setup();
        });
    }
    public setup() {
        const api: Toolkit.IAPI | undefined = this.getAPI();
        if (api === undefined) {
            return;
        }
        // Create a group (section) for settings
        api.getSettingsAPI().register(new Toolkit.Entry({
            key: 'selectionparser',
            path: '', // Put settings into root of settings tree
            name: 'Datetime Converter',
            desc: 'Converter any format to datetime format',
            type: Toolkit.ESettingType.standard,
        }));
        // Create setting
        api.getSettingsAPI().register(new SomestringSetting({
            key: 'pluginselectionparser',
            path: 'selectionparser',
            name: 'String setting',
            desc: 'This is test of string setting',
            type: Toolkit.ESettingType.standard,
            value: '',
        }));
    }
    public read() {
        const api: Toolkit.IAPI | undefined = this.getAPI();
        if (api === undefined) {
            return;
        }
        // Read some settings
        api.getSettingsAPI().get<boolean>('PluginsUpdates', 'general.plugins').then((value: boolean) => {
            console.log(value);
        }).catch((error: Error) => {
            console.log(error);
        });
    }
}
// To create selection parse we should extend class from SelectionParser class
// Our class should have at least two public methods:
// - getParserName(selection: string): string | undefined
// - parse(selection: string, themeTypeRef: Toolkit.EThemeType)
// tslint:disable-next-line: max-classes-per-file
export class SelectionParser extends Toolkit.SelectionParser {
    /**
     * Method with be called by chipmunk before show context menu in main view.
     * If selection acceptable by parser, method should return name on menu item
     * in context menu of chipmunk.
     * If selection couldn't be parsered, method should return undefined. In this
     * case menu item in context menu for this parser will not be show.
     * @param selection { string } - selected text in main view of chipmunk
     * @returns { string } - name of menu item in context menu
     * @returns { undefined } - in case if menu item should not be shown in context menu
     */
    public getParserName(selection: string): string | undefined {
        const date: Date | undefined = this._getDate(selection);
        return date instanceof Date ? 'Convert to DateTime' : undefined;
    }
    /**
     * Method with be called by chipmunk if user will select menu item (see getParserName)
     * in context menu of selection in main view.
     * @param selection { string } - selected text in main view of chipmunk
     * @param themeTypeRef { EThemeType } - name of current color theme
     * @returns { string } - parsed string
     */
    public parse(selection: string, themeTypeRef: Toolkit.EThemeType): string {
        const date: Date | undefined = this._getDate(selection);
        return date !== undefined ? date.toUTCString() : '';
    }
    private _getDate(selection: string): Date | undefined {
        const num: number = parseInt(selection, 10);
        if (!isFinite(num) || isNaN(num)) {
            return undefined;
        }
        const date: Date = new Date(num);
        return date instanceof Date ? date : undefined;
    }
}
// To delivery plugin into chipmunk we should use chipmunk's gateway
// It's stored in global variable "chipmunk"
// Gateway has a method "setPluginExports". With this method we can
// define a list of exported parsers.
const gate: Toolkit.PluginServiceGate | undefined = (window as any).chipmunk;
if (gate === undefined) {
    // This situation isn't possible, but let's check it also
    console.error(`Fail to find chipmunk gate.`);
} else {
    gate.setPluginExports({
        // Name of property (in this case it's "datetime" could be any. Chipmunk doesn't check
        // a name of property, but detecting a parent class.
        datetime: new SelectionParser(),
        // Share service with chipmunk
        service: new Service(),
    });
}
</code></pre>
</div>
<h2 id="shell"><a class="header" href="#shell">Shell</a></h2>
<p>The plugin <strong>Shell</strong> creates an input in which console commands can be typed whereas the output will be directed into the output section of Chipmunk.</p>
<pre><code>&#9500;&#9472;&#9472; process
&#9474;   &#9500;&#9472;&#9472; src
&#9474;   &#9474;   &#9500;&#9472;&#9472; env.logger.parameters.ts
&#9474;   &#9474;   &#9500;&#9472;&#9472; env.logger.ts
&#9474;   &#9474;   &#9500;&#9472;&#9472; main.ts
&#9474;   &#9474;   &#9500;&#9472;&#9472; process.env.ts
&#9474;   &#9474;   &#9500;&#9472;&#9472; process.fork.ts
&#9474;   &#9474;   &#9492;&#9472;&#9472; service.stream.ts
&#9474;   &#9500;&#9472;&#9472; package.json
&#9474;   &#9492;&#9472;&#9472; tsconfig.json
&#9492;&#9472;&#9472; render
    &#9500;&#9472;&#9472; src
    &#9474;   &#9500;&#9472;&#9472; lib
    &#9474;   &#9474;   &#9500;&#9472;&#9472; common
    &#9474;   &#9474;   &#9474;   &#9500;&#9472;&#9472; host.events.ts
    &#9474;   &#9474;   &#9474;   &#9492;&#9472;&#9472; interface.settings.ts
    &#9474;   &#9474;   &#9500;&#9472;&#9472; parsers
    &#9474;   &#9474;   &#9474;   &#9500;&#9472;&#9472; parser.rest.ts
    &#9474;   &#9474;   &#9474;   &#9492;&#9472;&#9472; parser.row.ts
    &#9474;   &#9474;   &#9500;&#9472;&#9472; tools
    &#9474;   &#9474;   &#9474;   &#9492;&#9472;&#9472; ansi.colors.ts
    &#9474;   &#9474;   &#9500;&#9472;&#9472; views
    &#9474;   &#9474;   &#9474;   &#9492;&#9472;&#9472; sidebar.vertical
    &#9474;   &#9474;   &#9474;       &#9500;&#9472;&#9472; compontent.ts
    &#9474;   &#9474;   &#9474;       &#9500;&#9472;&#9472; styles.less
    &#9474;   &#9474;   &#9474;       &#9492;&#9472;&#9472; template.html
    &#9474;   &#9474;   &#9500;&#9472;&#9472; module.ts
    &#9474;   &#9474;   &#9492;&#9472;&#9472; service.ts
    &#9474;   &#9492;&#9472;&#9472; public-api.ts
    &#9500;&#9472;&#9472; ng-package.json
    &#9500;&#9472;&#9472; package.json
    &#9500;&#9472;&#9472; tsconfig.lib.json
    &#9500;&#9472;&#9472; tsconfig.spec.json
    &#9492;&#9472;&#9472; tslint.json
</code></pre>
<h3 id="process-1"><a class="header" href="#process-1">Process</a></h3>
<div class="tab shp">
  <button class="tablinks" onclick="openCode(event, 'shp_env.logger.parameters.ts')">env.logger.parameters.ts</button>
  <button class="tablinks" onclick="openCode(event, 'shp_env.logger.ts')">env.logger.ts</button>
  <button class="tablinks active" onclick="openCode(event, 'shp_main.ts')">main.ts</button>
  <button class="tablinks" onclick="openCode(event, 'shp_process.env.ts')">process.env.ts</button>
  <button class="tablinks" onclick="openCode(event, 'shp_process.fork.ts')">process.fork.ts</button>
  <button class="tablinks" onclick="openCode(event, 'shp_service.stream.ts')">service.stream.ts</button>
</div>
<div id="shp_env.logger.parameters.ts" class="tabcontent shp">
<pre><code class="language-Javascript">const DEFAUT_ALLOWED_CONSOLE = {
    DEBUG: true,
    ENV: true,
    ERROR: true,
    INFO: true,
    VERBOS: false,
    WARNING: true,
};
export type TOutputFunc = (...args: any[]) => any;
/**
 * @class
 * Settings of logger
 *
 * @property {boolean} console - Show / not show logs in console
 * @property {Function} output - Sends ready string message as argument to output functions
 */
export class LoggerParameters {
    public console: boolean = true;
    public allowedConsole: {[key: string]: boolean} = {};
    public output: TOutputFunc | null = null;
    constructor(
        {
            console         = true,
            output          = null,
            allowedConsole  = DEFAUT_ALLOWED_CONSOLE,
        }: {
            console?: boolean,
            output?: TOutputFunc | null,
            allowedConsole?: {[key: string]: boolean },
        }) {
        this.console = console;
        this.output = output;
        this.allowedConsole = allowedConsole;
    }
}
</code></pre>
</div>
<div id="shp_env.logger.ts" class="tabcontent shp">
<pre><code class="language-Javascript">import { inspect } from 'util';
import { LoggerParameters } from './env.logger.parameters';
enum ELogLevels {
    INFO = 'INFO',
    DEBUG = 'DEBUG',
    WARNING = 'WARNING',
    VERBOS = 'VERBOS',
    ERROR = 'ERROR',
    ENV = 'ENV',
}
export type TOutputFunc = (...args: any[]) => any;
/**
 * @class
 * Logger
 */
export default class Logger {
    private _signature: string = '';
    private _parameters: LoggerParameters = new LoggerParameters({});
    /**
     * @constructor
     * @param {string} signature        - Signature of logger instance
     * @param {LoggerParameters} params - Logger parameters
     */
    constructor(signature: string, params?: LoggerParameters) {
        params instanceof LoggerParameters && (this._parameters = params);
        this._signature = signature;
    }
    public setOutput(output: TOutputFunc) {
        if (typeof output !== 'function') {
            this.error(`Fail to setup output function, because it should function, but had gotten: ${typeof output}`);
        }
        this._parameters.output = output;
    }
    /**
     * Publish info logs
     * @param {any} args - Any input for logs
     * @returns {string} - Formatted log-string
     */
    public info(...args: any[]) {
        return this._log(this._getMessage(...args), ELogLevels.INFO);
    }
    /**
     * Publish warnings logs
     * @param {any} args - Any input for logs
     * @returns {string} - Formatted log-string
     */
    public warn(...args: any[]) {
        return this._log(this._getMessage(...args), ELogLevels.WARNING);
    }
    /**
     * Publish verbose logs
     * @param {any} args - Any input for logs
     * @returns {string} - Formatted log-string
     */
    public verbose(...args: any[]) {
        return this._log(this._getMessage(...args), ELogLevels.VERBOS);
    }
    /**
     * Publish error logs
     * @param {any} args - Any input for logs
     * @returns {string} - Formatted log-string
     */
    public error(...args: any[]) {
        return this._log(this._getMessage(...args), ELogLevels.ERROR);
    }
    /**
     * Publish debug logs
     * @param {any} args - Any input for logs
     * @returns {string} - Formatted log-string
     */
    public debug(...args: any[]) {
        return this._log(this._getMessage(...args), ELogLevels.DEBUG);
    }
    /**
     * Publish environment logs (low-level stuff, support or tools)
     * @param {any} args - Any input for logs
     * @returns {string} - Formatted log-string
     */
    public env(...args: any[]) {
        return this._log(this._getMessage(...args), ELogLevels.ENV);
    }
    private _console(message: string, level: ELogLevels) {
        if (!this._parameters.console) {
            return false;
        }
        /* tslint:disable */
        this._parameters.allowedConsole[level] && console.log(message);
        /* tslint:enable */
    }
    private _output(message: string) {
        if (typeof this._parameters.output === 'function') {
            this._parameters.output(message);
            return true;
        } else {
            return false;
        }
    }
    private _getMessage(...args: any[]) {
        let message = ``;
        if (args instanceof Array) {
            args.forEach((smth: any, index: number) => {
                if (typeof smth !== 'string') {
                    message = `${message} (type: ${(typeof smth)}): ${inspect(smth)}`;
                } else {
                    message = `${message}${smth}`;
                }
                index < (args.length - 1) && (message = `${message},\n `);
            });
        }
        return message;
    }
    private _getTime(): string {
        const time: Date = new Date();
        return `${time.toJSON()}`;
    }
    private _log(message: string, level: ELogLevels) {
        message = `[${this._signature}]: ${message}`;
        if (!this._output(`[${this._getTime()}]${message}`)) {
            this._console(`[${this._getTime()}]${message}`, level);
        }
        return message;
    }
}
</code></pre>
</div>
<div id="shp_main.ts" class="tabcontent shp active">
<pre><code class="language-Javascript">import Logger from './env.logger';
import * as path from 'path';
import PluginIPCService, { ServiceState } from 'chipmunk.plugin.ipc';
import { IPCMessages } from 'chipmunk.plugin.ipc';
import StreamsService, { IStreamInfo } from './service.streams';
import { IForkSettings } from './process.fork';
class Plugin {
    private _logger: Logger = new Logger('Processes');
    constructor() {
        this._onStreamOpened = this._onStreamOpened.bind(this);
        this._onStreamClosed = this._onStreamClosed.bind(this);
        this._onIncomeRenderIPCMessage = this._onIncomeRenderIPCMessage.bind(this);
        PluginIPCService.subscribe(IPCMessages.PluginInternalMessage, this._onIncomeRenderIPCMessage);
        StreamsService.on(StreamsService.Events.onStreamOpened, this._onStreamOpened);
        StreamsService.on(StreamsService.Events.onStreamClosed, this._onStreamClosed);
    }
    private _onIncomeRenderIPCMessage(message: IPCMessages.PluginInternalMessage, response: (res: IPCMessages.TMessage) => any) {
        switch (message.data.command) {
            case 'command':
                return this._income_command(message).then(() => {
                    response(new IPCMessages.PluginInternalMessage({
                        data: {
                            status: 'done'
                        },
                        token: message.token,
                        stream: message.stream
                    }));
                }).catch((error: Error) => {
                    return response(new IPCMessages.PluginError({
                        message: error.message,
                        stream: message.stream,
                        token: message.token,
                        data: {
                            command: message.data.command
                        }
                    }));
                });
            case 'stop':
                return this._income_stop(message).then(() => {
                    response(new IPCMessages.PluginInternalMessage({
                        data: {
                            status: 'done'
                        },
                        token: message.token,
                        stream: message.stream
                    }));
                }).catch((error: Error) => {
                    return response(new IPCMessages.PluginError({
                        message: error.message,
                        stream: message.stream,
                        token: message.token,
                        data: {
                            command: message.data.command
                        }
                    }));
                });
            case 'write':
                return this._income_write(message).then(() => {
                    response(new IPCMessages.PluginInternalMessage({
                        data: {
                            status: 'done'
                        },
                        token: message.token,
                        stream: message.stream
                    }));
                }).catch((error: Error) => {
                    return response(new IPCMessages.PluginError({
                        message: error.message,
                        stream: message.stream,
                        token: message.token,
                        data: {
                            command: message.data.command
                        }
                    }));
                });
            case 'getSettings':
                return this._income_getSettings(message).then((settings: IForkSettings) => {
                    response(new IPCMessages.PluginInternalMessage({
                        data: {
                            settings: settings
                        },
                        token: message.token,
                        stream: message.stream
                    }));
                }).catch((error: Error) => {
                    return response(new IPCMessages.PluginError({
                        message: error.message,
                        stream: message.stream,
                        token: message.token,
                        data: {
                            command: message.data.command
                        }
                    }));
                });
            default:
                this._logger.warn(`Unknown commad: ${message.data.command}`);
        }
    }
    private _income_command(message: IPCMessages.PluginInternalMessage): Promise<void> {
        return new Promise((resolve, reject) => {
            const streamId: string | undefined = message.stream;
            if (streamId === undefined) {
                return reject(new Error(this._logger.warn(`No target stream ID provided`)));
            }
            // Get a target stream
            const stream: IStreamInfo | undefined = StreamsService.get(streamId);
            if (stream === undefined) {
                return reject(new Error(this._logger.warn(`Fail to find a stream "${streamId}" in storage.`)));
            }
            const cmd: string | undefined = message.data.cmd;
            if (typeof cmd !== 'string') {
                return reject(new Error(this._logger.warn(`Fail to execute command for a stream "${streamId}" because command isn't a string, but ${typeof cmd}.`)));
            }
            // Check: is it "cd" command. If yes, change cwd of settings and resolve
            const cd: boolean | Error = this._cwdChange(cmd, stream);
            if (cd === true) {
                return resolve();
            } else if (cd instanceof Error) {
                return reject(cd);
            }
            // Ref fork to stream
            StreamsService.refFork(streamId, cmd);
            resolve();            
        });
    }
    private _income_stop(message: IPCMessages.PluginInternalMessage): Promise<void> {
        return new Promise((resolve, reject) => {
            const streamId: string | undefined = message.stream;
            if (streamId === undefined) {
                return reject(new Error(this._logger.warn(`No target stream ID provided`)));
            }
            // Get a target stream
            const stream: IStreamInfo | undefined = StreamsService.get(streamId);
            if (stream === undefined) {
                return reject(new Error(this._logger.warn(`Fail to find a stream "${streamId}" in storage.`)));
            }
            // Ref fork to stream
            StreamsService.unrefFork(streamId);
            resolve();            
        });
    }
    private _income_write(message: IPCMessages.PluginInternalMessage): Promise<void> {
        return new Promise((resolve, reject) => {
            const streamId: string | undefined = message.stream;
            if (streamId === undefined) {
                return reject(new Error(this._logger.warn(`No target stream ID provided`)));
            }
            // Get a target stream
            const stream: IStreamInfo | undefined = StreamsService.get(streamId);
            if (stream === undefined) {
                return reject(new Error(this._logger.warn(`Fail to find a stream "${streamId}" in storage.`)));
            }
            const input: any = message.data.input;
            if (input === undefined) {
                return reject(new Error(this._logger.warn(`Fail to write into stream "${streamId}" because input is undefined.`)));
            }
            // Check: is fork still running
            if (stream.fork === undefined || stream.fork.isClosed()) {
                return reject(new Error(this._logger.warn(`Fail to write into stream "${streamId}" because fork is closed.`)));
            }
            // Write data
            stream.fork.write(input).then(resolve).catch(reject);
        });
    }
    private _income_getSettings(message: IPCMessages.PluginInternalMessage): Promise<IForkSettings> {
        return new Promise((resolve, reject) => {
            const streamId: string | undefined = message.stream;
            if (streamId === undefined) {
                return reject(new Error(this._logger.warn(`No target stream ID provided`)));
            }
            // Get a target stream
            const stream: IStreamInfo | undefined = StreamsService.get(streamId);
            if (stream === undefined) {
                return reject(new Error(this._logger.warn(`Fail to find a stream "${streamId}" in storage.`)));
            }
            resolve(stream.settings);            
        });
    }
    private _cwdChange(command: string, stream: IStreamInfo): boolean | Error {
        const cdCmdReg = /^cd\s*([^\s]*)/gi;
        const match: RegExpExecArray | null = cdCmdReg.exec(command.trim());
        if (match === null) {
            return false;
        }
        if (match.length !== 2) {
            return false;
        }
        try {
            stream.settings.cwd = path.resolve(stream.settings.cwd, match[1]);
        } catch (e) {
            this._logger.error(`Fail to make "cd" due error: ${e.message}`);
            return e;
        }
        StreamsService.updateSettings(stream.streamId, stream.settings);
        return true;
    }
    private _onStreamOpened(streamId: string) {
        // Get a target stream
        const stream: IStreamInfo | undefined = StreamsService.get(streamId);
        if (stream === undefined) {
            return this._logger.warn(`Event "onStreamOpened" was triggered, but fail to find a stream "${streamId}" in storage.`);
        }
        const error: Error | undefined = StreamsService.updateSettings(stream.streamId);
        if (error instanceof Error) {
            return this._logger.warn(`Event "onStreamOpened" was triggered, but fail to notify host due error: ${error.message}.`);
        }
    }
    private _onStreamClosed(streamId: string) {
    }
}
const app: Plugin = new Plugin();
// Notify core about plugin
ServiceState.accept().catch((err: Error) => {
    console.log(`Fail to notify core about plugin due error: ${err.message}`);
});
</code></pre>
</div>
<div id="shp_process.env.ts" class="tabcontent shp">
<pre><code class="language-Javascript">import { exec, ExecOptions } from 'child_process';
import * as OS from 'os';
import * as Path from 'path';
import * as shellEnv from 'shell-env';
export function shell(command: string, options: ExecOptions = {}): Promise<string> {
    return new Promise((resolve, reject) => {
        options = typeof options === 'object' ? (options !== null ? options : {}) : {};
        exec(command, options, (error: Error | null, stdout: string, stderr: string) => {
            if (error instanceof Error) {
                return reject(error);
            }
            if (stderr.trim() !== '') {
                return reject(new Error(`Finished deu error: ${stderr}`));
            }
            resolve(stdout);
        });
    });
}
export enum EPlatforms {
    aix = 'aix',
    darwin = 'darwin',
    freebsd = 'freebsd',
    linux = 'linux',
    openbsd = 'openbsd',
    sunos = 'sunos',
    win32 = 'win32',
    android = 'android',
}
export type TEnvVars = { [key: string]: string };
export function getOSEnvVars(shell: string): Promise<TEnvVars> {
    return new Promise((resolve) => {
        if (OS.platform() !== EPlatforms.darwin) {
            return resolve(Object.assign({}, process.env) as TEnvVars);
        }
        shellEnv(shell).then((env) => {
            // console.log(`Next os env variables were detected:`);
            // console.log(env);
            resolve(env);
        }).catch((error: Error) => {
            console.log('Shell-Env Error:');
            console.log(error);
            resolve(Object.assign({}, process.env) as TEnvVars);
        });
    });
}
export function defaultShell(): Promise<string> {
    return new Promise((resolve) => {
        let shellPath: string | undefined = '';
        let command: string = '';
        switch (OS.platform()) {
            case EPlatforms.aix:
            case EPlatforms.android:
            case EPlatforms.darwin:
            case EPlatforms.freebsd:
            case EPlatforms.linux:
            case EPlatforms.openbsd:
            case EPlatforms.sunos:
                shellPath = process.env.SHELL;
                command = 'echo $SHELL';
                break;
            case EPlatforms.win32:
                shellPath = process.env.COMSPEC;
                command = 'ECHO %COMSPEC%';
                break;
        }
        if (shellPath) {
            return resolve(shellPath);
        }
        // process didn't resolve shell, so we query it manually
        shell(command).then((stdout: string) => {
            resolve(stdout.trim());
        }).catch((error: Error) => {
            // COMSPEC should always be available on windows.
            // Therefore: we will try to use /bin/sh as error-mitigation
            resolve("/bin/sh");
        });
    });
}
export function shells(): Promise<string[]> {
    return new Promise((resolve) => {
        let command: string = '';
        switch (OS.platform()) {
            case EPlatforms.aix:
            case EPlatforms.android:
            case EPlatforms.darwin:
            case EPlatforms.freebsd:
            case EPlatforms.linux:
            case EPlatforms.openbsd:
            case EPlatforms.sunos:
                command = 'cat /etc/shells';
                break;
            case EPlatforms.win32:
                // TODO: Check solution with win
                command = 'cmd.com';
                break;
        }
        shell(command).then((stdout: string) => {
            const values: string[] = stdout.split(/[\n\r]/gi).filter((value: string) => {
                return value.indexOf('/') === 0;
            });
            resolve(values);
        }).catch((error: Error) => {
            resolve([]);
        });
    });
}
export function getExecutedModulePath(): string {
    return Path.normalize(`${Path.dirname(require.main === void 0 ? __dirname : require.main.filename)}`);
}
export function getHomePath(): string {
    return Path.normalize(`${OS.homedir()}`);
}
</code></pre>
</div>
<div id="shp_process.fork.ts" class="tabcontent shp">
<pre><code class="language-Javascript">import { spawn, ChildProcess } from 'child_process';
import { EventEmitter } from 'events';
export interface IForkSettings {
    env: { [key: string]: string };
    shell: string | boolean;
    cwd: string;
}
export interface ICommand {
    cmd: string;
    settings: IForkSettings;
}
export default class Fork extends EventEmitter {
    public static Events = {
        data: 'data',
        exit: 'exit'
    };
    public Events = Fork.Events;
    private _process: ChildProcess | undefined;
    private _closed: boolean = true;
    private _command: ICommand;
    constructor(command: ICommand) {
        super();
        this._command = command;
    }
    public execute() {
        this._process = spawn(this._command.cmd, {
            cwd: this._command.settings.cwd,
            env: this._command.settings.env,
            shell: this._command.settings.shell,
        });
        this._closed = false;
        this._process.stdout.on('data', this._onStdout.bind(this));
        this._process.stderr.on('data', this._onStderr.bind(this));
        this._process.on('exit', this._onExit.bind(this));
        this._process.on('close', this._onClose.bind(this));
        this._process.on('disconnect', this._onDisconnect.bind(this));
        this._process.on('error', this._onError.bind(this));
    }
    public write(data: any): Promise<void> {
        return new Promise((resolve, reject) => {
            if (this._process === undefined) {
                return reject(new Error(`Shell process isn't available. It was destroyed or wasn't created at all.`));
            }
            this._process.stdin.write(data, (error: Error | null | undefined) => {
                if (error) {
                    return reject(error);
                }
                resolve();
            });
        });
    }
    public destroy() {
        this._closed = true;
        if (this._process === undefined) {
            return;
        }
        this.removeAllListeners();
        this._process.removeAllListeners();
        this._process.kill();
        this._process = undefined;
    }
    public isClosed(): boolean {
        return this._closed;
    }
    private _onStdout(chunk: any) {
        this.emit(this.Events.data, chunk);
    }
    private _onStderr(chunk: any) {
        this.emit(this.Events.data, chunk);
    }
    private _onExit() {
        this.emit(this.Events.exit);
        this.destroy();
    }
    private _onClose() {
        this.emit(this.Events.exit);
        this.destroy();
    }
    private _onDisconnect() {
        this.emit(this.Events.exit);
        this.destroy();
    }
    private _onError(error: Error) {
        this.emit(this.Events.data, error.message);
        this.emit(this.Events.exit);
        this.destroy();
    }
}
</code></pre>
</div>
<div id="shp_service.stream.ts" class="tabcontent shp">
<pre><code class="language-Javascript">import Logger from './env.logger';
import PluginIPCService from 'chipmunk.plugin.ipc';
import Fork, { IForkSettings } from './process.fork';
import * as EnvModule from './process.env';
import { EventEmitter } from 'events';
import * as os from 'os';
export interface IStreamInfo {
    fork: Fork | undefined;
    streamId: string;
    settings: IForkSettings;
}
class StreamsService extends EventEmitter {
    public Events = {
        onStreamOpened: 'onStreamOpened',
        onStreamClosed: 'onStreamClosed',
    };
    private _logger: Logger = new Logger('StreamsService');
    private _streams: Map<string, IStreamInfo> = new Map();
    constructor() {
        super();
        this._onOpenStream = this._onOpenStream.bind(this);
        this._onCloseStream = this._onCloseStream.bind(this);
        PluginIPCService.on(PluginIPCService.Events.openStream, this._onOpenStream);
        PluginIPCService.on(PluginIPCService.Events.closeStream, this._onCloseStream);
    }
    public get(streamId: string): IStreamInfo | undefined {
        return this._streams.get(streamId);
    }
    public refFork(streamId: string, command: string): Error | undefined {
        const stream: IStreamInfo | undefined = this._streams.get(streamId);
        if (stream === undefined) {
            return new Error(`Stream ${streamId} is not found. Cannot set fork.`);
        }
        // Check: does fork already exist (previous commands still running)
        if (stream.fork !== undefined) {
            return new Error(`Stream ${streamId} has running fork, cannot start other.`);
        }
        // Create fork to execute command
        const fork: Fork = new Fork({ 
            cmd: command,
            settings: stream.settings
        });
        // Attach listeners
        fork.on(Fork.Events.data, (chunk) => {
            PluginIPCService.sendToStream(chunk, streamId);
        });
        fork.on(Fork.Events.exit, () => {
            this.unrefFork(streamId);
        });
        // Save fork
        stream.fork = fork;
        this._streams.set(streamId, stream);
        // Start forl
        fork.execute();
        PluginIPCService.sendToPluginHost(streamId, {
            event: 'ForkStarted',
            streamId: streamId
        });
    }
    public unrefFork(streamId: string): Error | undefined {
        const stream: IStreamInfo | undefined = this._streams.get(streamId);
        if (stream === undefined) {
            return new Error(`Stream ${streamId} is not found. Cannot set fork.`);
        }
        if (stream.fork !== undefined && !stream.fork.isClosed()) {
            stream.fork.destroy();
        }
        stream.fork = undefined;
        this._streams.set(streamId, stream);
        PluginIPCService.sendToPluginHost(streamId, {
            event: 'ForkClosed',
            streamId: streamId
        });
    }
    public updateSettings(streamId: string, settings?: IForkSettings): Error | undefined {
        const stream: IStreamInfo | undefined = this._streams.get(streamId);
        if (stream === undefined) {
            return new Error(`Stream ${streamId} is not found. Cannot update settings.`);
        }
        if (settings !== undefined) {
            stream.settings = Object.assign({}, settings);
            this._streams.set(streamId, stream);
        }
        PluginIPCService.sendToPluginHost(streamId, {
            event: 'SettingsUpdated',
            settings: stream.settings,
            streamId: streamId
        });
    }
    private _getInitialOSEnv(defaults: EnvModule.TEnvVars): EnvModule.TEnvVars {
        defaults.TERM = 'xterm-256color';
        return defaults;
    }
    private _onOpenStream(streamId: string) {
        if (this._streams.has(streamId)) {
            return this._logger.warn(`Stream ${streamId} is already created.`);
        }
        EnvModule.defaultShell().then((userShell: string) => {
            console.log(`Detected default shell: ${userShell}`);
            EnvModule.getOSEnvVars(userShell).then((env: EnvModule.TEnvVars) => {
                //Apply default terminal color scheme
                this._createStream(streamId, os.homedir(), this._getInitialOSEnv(env), userShell);
            }).catch((error: Error) => {
                this._logger.warn(`Failed to get OS env vars for stream ${streamId} due to error: ${error.message}. Default node-values will be used .`);
                this._createStream(streamId, os.homedir(), this._getInitialOSEnv(Object.assign({}, process.env) as EnvModule.TEnvVars), userShell);
            });
        }).catch((gettingShellErr: Error) => {
            this._logger.env(`Failed to create stream "${streamId}" due to error: ${gettingShellErr.message}.`)
        });
    }
    private _onCloseStream(streamId: string) {
        const stream: IStreamInfo | undefined = this._streams.get(streamId);
        if (stream === undefined) {
            return this._logger.warn(`Stream ${streamId} is already closed.`);
        }
        // Check fork before (if it's still working)
        if (stream.fork !== undefined) {
            stream.fork.destroy();
        }
        // Remove stream now
        this._streams.delete(streamId);
        this.emit(this.Events.onStreamClosed, streamId);
    }
    private _createStream(streamId: string, cwd: string, env: EnvModule.TEnvVars, shell: string) {
        this._streams.set(streamId, {
            fork: undefined,
            streamId: streamId,
            settings: {
                cwd: cwd,
                shell: shell,
                env: env
            }
        });
        this.emit(this.Events.onStreamOpened, streamId);
        this._logger.env(`Stream "${streamId}" is bound with cwd "${cwd}".`);
    }
}
export default (new StreamsService());
</code></pre>
</div>
<h3 id="render-1"><a class="header" href="#render-1">Render</a></h3>
<div class="tab shr">
  <button class="tablinks" onclick="openCode(event, 'shr_public_api.ts')">public_api.ts</button>
  <button class="tablinks" onclick="openCode(event, 'shr_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'shr_service.ts')">service.ts</button>
  <button class="tablinks" onclick="openCode(event, 'shr_host.events.ts')">host.events.ts</button>
  <button class="tablinks" onclick="openCode(event, 'shr_interface.settings.ts')">interface.settings.ts</button>
  <button class="tablinks" onclick="openCode(event, 'shr_parser.rest.ts')">parser.rest.ts</button>
  <button class="tablinks" onclick="openCode(event, 'shr_parser.row.ts')">parser.row.ts</button>
  <button class="tablinks" onclick="openCode(event, 'shr_ansi.colors.ts')">ansi.colors.ts</button>
  <button class="tablinks active" onclick="openCode(event, 'shr_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'shr_styles.less')">styles.less</button>
  <button class="tablinks" onclick="openCode(event, 'shr_template.html')">template.html</button>
</div>
<div id="shr_public_api.ts" class="tabcontent shr">
<pre><code class="language-Javascript">/*
 * Public API Surface of terminal
 */
export * from './lib/views/sidebar.vertical/component';
export * from './lib/module';
export { parserRow } from './lib/parsers/parser.row';
export { parserRest } from './lib/parsers/parser.rest';
</code></pre>
</div>
<div id="shr_module.ts" class="tabcontent shr">
<pre><code class="language-Javascript">import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { SidebarVerticalComponent } from './views/sidebar.vertical/component';
import { PrimitiveModule } from 'chipmunk-client-material';
import * as Toolkit from 'chipmunk.client.toolkit';
@NgModule({
    entryComponents: [ SidebarVerticalComponent],
    declarations: [ SidebarVerticalComponent],
    imports: [ CommonModule, FormsModule, PrimitiveModule ],
    exports: [ SidebarVerticalComponent]
})
export class PluginModule extends Toolkit.PluginNgModule {
    constructor() {
        super('OS', 'Allows to execute local processes');
    }
}
</code></pre>
</div>
<div id="shr_service.ts" class="tabcontent shr">
<pre><code class="language-Javascript">import { Injectable } from '@angular/core';
@Injectable({
  providedIn: 'root'
})
export class TerminalService {
  constructor() { }
}
</code></pre>
</div>
<div id="shr_host.events.ts" class="tabcontent shr">
<pre><code class="language-Javascript">export enum EHostEvents {
    ForkStarted = 'ForkStarted',
    ForkClosed = 'ForkClosed',
    SettingsUpdated = 'SettingsUpdated',
}
export enum EHostCommands {
    command = 'command',
    write = 'write',
    stop = 'stop',
    getSettings = 'getSettings',
}
</code></pre>
</div>
<div id="shr_interface.settings.ts" class="tabcontent shr">
<pre><code class="language-Javascript">export interface IForkSettings {
    env: { [key: string]: string };
    shell: string | boolean;
    cwd: string;
}
</code></pre>
</div>
<div id="shr_parser.rest.ts" class="tabcontent shr">
<pre><code class="language-Javascript">import { AnsiEscapeSequencesColors } from '../tools/ansi.colors';
export function parserRest(str: string): string {
    const colors: AnsiEscapeSequencesColors = new AnsiEscapeSequencesColors();
    return colors.getHTML(str);
}
</code></pre>
</div>
<div id="shr_parser.row.ts" class="tabcontent shr">
<pre><code class="language-Javascript">import { AnsiEscapeSequencesColors } from '../tools/ansi.colors';
export function parserRow(str: string): string {
    const colors: AnsiEscapeSequencesColors = new AnsiEscapeSequencesColors();
    return colors.getHTML(str);
}
</code></pre>
</div>
<div id="shr_ansi.colors.ts" class="tabcontent shr">
<pre><code class="language-Javascript">// tslint:disable:max-line-length
// tslint:disable:no-inferrable-types
// Base: https://en.wikipedia.org/wiki/ANSI_escape_code
const RegExps = {
    color: /\x1b\[([0-9;]*)m/gi
};
class AnsiColorDefinition {
    private _value: string;
    private readonly _map: { [key: string]: (key: string, params: string[]) => string } = {
        '0': this._fn_drop.bind(this), '1': this._fn_bold.bind(this), '2': this._fn_ubold.bind(this), '3': this._fn_italic, '4': this._fn_underline.bind(this),
        '5': this._fn_dummy.bind(this), '6': this._fn_dummy.bind(this), '7': this._fn_dummy.bind(this), '8': this._fn_dummy.bind(this), '9': this._fn_dummy.bind(this),
        '10': this._fn_dummy.bind(this), '11': this._fn_dummy.bind(this), '12': this._fn_dummy.bind(this), '13': this._fn_dummy.bind(this), '14': this._fn_dummy.bind(this),
        '15': this._fn_dummy.bind(this), '16': this._fn_dummy.bind(this), '17': this._fn_dummy.bind(this), '18': this._fn_dummy.bind(this), '19': this._fn_dummy.bind(this),
        '20': this._fn_dummy.bind(this), '21': this._fn_dummy.bind(this), '22': this._fn_dummy.bind(this), '23': this._fn_nounderline.bind(this), '24': this._fn_nounderline.bind(this),
        '25': this._fn_dummy.bind(this), '26': this._fn_dummy.bind(this), '27': this._fn_dummy.bind(this), '28': this._fn_dummy.bind(this), '29': this._fn_dummy.bind(this),
        '30': this._fn_foreground.bind(this), '31': this._fn_foreground.bind(this), '32': this._fn_foreground.bind(this), '33': this._fn_foreground.bind(this), '34': this._fn_foreground.bind(this),
        '35': this._fn_foreground.bind(this), '36': this._fn_foreground.bind(this), '37': this._fn_foreground.bind(this), '38': this._fn_foreground.bind(this), '39': this._fn_foreground.bind(this),
        '40': this._fn_background.bind(this), '41': this._fn_background.bind(this), '42': this._fn_background.bind(this), '43': this._fn_background.bind(this), '44': this._fn_background.bind(this),
        '45': this._fn_background.bind(this), '46': this._fn_background.bind(this), '47': this._fn_background.bind(this), '48': this._fn_background.bind(this), '49': this._fn_background.bind(this),
        '50': this._fn_dummy.bind(this), '51': this._fn_dummy.bind(this), '52': this._fn_dummy.bind(this), '53': this._fn_dummy.bind(this), '54': this._fn_dummy.bind(this),
        '55': this._fn_dummy.bind(this), '56': this._fn_dummy.bind(this), '57': this._fn_dummy.bind(this), '58': this._fn_dummy.bind(this), '59': this._fn_dummy.bind(this),
        '60': this._fn_dummy.bind(this), '61': this._fn_dummy.bind(this), '62': this._fn_dummy.bind(this), '63': this._fn_dummy.bind(this), '64': this._fn_dummy.bind(this),
        '65': this._fn_dummy.bind(this),
    };
    private readonly _mapLength: { [key: string]: number } = {
        '0': 0, '1': 0, '2': 0, '3': 0, '4': 0,
        '5': 0, '6': 0, '7': 0, '8': 0, '9': 0,
        '10': 0, '11': 0, '12': 0, '13': 0, '14': 0,
        '15': 0, '16': 0, '17': 0, '18': 0, '19': 0,
        '20': 0, '21': 0, '22': 0, '23': 0, '24': 0,
        '25': 0, '26': 0, '27': 0, '28': 0, '29': 0,
        '30': 0, '31': 0, '32': 0, '33': 0, '34': 0,
        '35': 0, '36': 0, '37': 0, '38': 0, '39': 0,
        '40': 0, '41': 0, '42': 0, '43': 0, '44': 0,
        '45': 0, '46': 0, '47': 0, '48': 0, '49': 0,
        '50': 0, '51': 0, '52': 0, '53': 0, '54': 0,
        '55': 0, '56': 0, '57': 0, '58': 0, '59': 0,
        '60': 0, '61': 0, '62': 0, '63': 0, '64': 0,
        '65': 0,
    };
    constructor(value: string) {
        this._value = value;
    }
    public getStyle(): string {
        const parts: string[] = this._value.split(';');
        let styles: string = '';
        do {
            const key: string = parts[0];
            if (!this._isKeyValid(key)) {
                // Here is should be some log message, because key is unknown
                parts.splice(0, 1);
            } else {
                // Remove current key
                parts.splice(0, 1);
                // Get styles
                styles += this._map[key](key, parts);
            }
        } while (parts.length > 0);
        return styles;
    }
    private _isKeyValid(key: string): boolean {
        return this._mapLength[key] !== undefined;
    }
    private _decode8BitAnsiColor(ansi: number): string {
        // https://gist.github.com/MightyPork/1d9bd3a3fd4eb1a661011560f6921b5b
        const low_rgb = [
            '#000000', '#800000', '#008000', '#808000', '#000080', '#800080', '#008080', '#c0c0c0',
            '#808080', '#ff0000', '#00ff00', '#ffff00', '#0000ff', '#ff00ff', '#00ffff', '#ffffff'
        ];
        if (ansi < 0 || ansi > 255)  { return '#000'; }
        if (ansi < 16) { return low_rgb[ansi]; }
        if (ansi > 231) {
          const s = (ansi - 232) * 10 + 8;
          return `rgb(${s},${s},${s})`;
        }
        const n = ansi - 16;
        let b = n % 6;
        let g = (n - b) / 6 % 6;
        let r = (n - b - g * 6) / 36 % 6;
        b = b ? b * 40 + 55 : 0;
        r = r ? r * 40 + 55 : 0;
        g = g ? g * 40 + 55 : 0;
        return `rgb(${r},${g},${b})`;
    }
    private _fn_bold(key: string, params: string[]): string {
        return 'fontWeight: bold;';
    }
    private _fn_ubold(key: string, params: string[]): string {
        return 'fontWeight: normal;';
    }
    private _fn_italic(key: string, params: string[]): string {
        return 'fontStyle: italic;';
    }
    private _fn_underline(key: string, params: string[]): string {
        return 'textDecoration: underline;';
    }
    private _fn_nounderline(key: string, params: string[]): string {
        return 'textDecoration: none;';
    }
    private _fn_foreground(key: string, params: string[]): string {
        switch (key) {
            case '30':
                return 'color: rgb(0,0,0);';
            case '31':
                return 'color: rgb(170,0,0);';
            case '32':
                return 'color: rgb(0,170,0);';
            case '33':
                return 'color: rgb(170,85,0);';
            case '34':
                return 'color: rgb(0,0,170);';
            case '35':
                return 'color: rgb(170,0,170);';
            case '36':
                return 'color: rgb(0,170,170);';
            case '37':
                return 'color: rgb(170,170,170);';
            case '38':
                if (params[0] === '5' && params.length >= 2) {
                    const cut = params.splice(0, 2);
                    return `color: ${this._decode8BitAnsiColor(parseInt(cut[1], 10))};`;
                } else if (params[0] === '2' && params.length >= 4) {
                    const cut = params.splice(0, 4);
                    return `color: rgb(${cut[1]}, ${cut[2]}, ${cut[3]});`;
                } else {
                    return '';
                }
            case '39':
                return 'color: inherit;';
            default:
                return '';
        }
    }
    private _fn_background(key: string, params: string[]): string {
        switch (key) {
            case '40':
                return 'backgroundColor: rgb(0,0,0);';
            case '41':
                return 'backgroundColor: rgb(128,0,0);';
            case '42':
                return 'backgroundColor: rgb(0,128,0);';
            case '43':
                return 'backgroundColor: rgb(128,128,0);';
            case '44':
                return 'backgroundColor: rgb(0,0,128);';
            case '45':
                return 'backgroundColor: rgb(128,0,128);';
            case '46':
                return 'backgroundColor: rgb(0,128,128);';
            case '47':
                return 'backgroundColor: rgb(192,192,192);';
            case '48':
                if (params[0] === '5' && params.length >= 2) {
                    const cut = params.splice(0, 2);
                    return `backgroundColor: ${this._decode8BitAnsiColor(parseInt(cut[1], 10))};`;
                } else if (params[0] === '2' && params.length >= 4) {
                    const cut = params.splice(0, 4);
                    return `backgroundColor: rgb(${cut[1]}, ${cut[2]}, ${cut[3]});`;
                } else {
                    return '';
                }
            case '49':
                return 'backgroundColor: inherit;';
            default:
                return '';
        }
    }
    private _fn_drop(key: string, params: string[]): string {
        return '';
    }
    private _fn_dummy(key: string, params: string[]): string {
        return '';
    }
}
export class AnsiEscapeSequencesColors {
    constructor() {
    }
    public getHTML(input: string): string {
        let opened: number = 0;
        input = input.replace(RegExps.color, (substring: string, match: string, offset: number, whole: string) => {
            const styleDef: AnsiColorDefinition = new AnsiColorDefinition(match);
            const style: string = styleDef.getStyle();
            opened ++;
            return style !== '' ? `<span style="${style}">` : `<span>`;
        });
        input += `</span>`.repeat(opened);
        input = input.replace(/<span><\/span>/gi, '');
        return input;
    }
}
</code></pre>
</div>
<div id="shr_component.ts" class="tabcontent shr active">
<pre><code class="language-Javascript">// tslint:disable:no-inferrable-types
import { Component, OnDestroy, ChangeDetectorRef, AfterViewInit, Input, ElementRef, ViewChild } from '@angular/core';
import { EHostEvents, EHostCommands } from '../../common/host.events';
import { IForkSettings } from '../../common/interface.settings';
import * as Toolkit from 'chipmunk.client.toolkit';
export interface IEnvVar {
    key: string;
    value: string;
}
interface IState {
    _ng_envvars: IEnvVar[];
    _ng_settings: IForkSettings | undefined;
    _ng_working: boolean;
    _ng_cmd: string;
}
const state: Toolkit.ControllerState<IState> = new Toolkit.ControllerState<IState>();
@Component({
    selector: 'lib-sidebar-ver',
    templateUrl: './template.html',
    styleUrls: ['./styles.less']
})
export class SidebarVerticalComponent implements AfterViewInit, OnDestroy {
    @ViewChild('cmdinput', {static: false}) _ng_input: ElementRef;
    @Input() public api: Toolkit.IAPI;
    @Input() public session: string;
    @Input() public sessions: Toolkit.ControllerSessionsEvents;
    public _ng_envvars: IEnvVar[] = [];
    public _ng_settings: IForkSettings | undefined;
    public _ng_working: boolean = false;
    public _ng_cmd: string = '';
    private _subscriptions: { [key: string]: Toolkit.Subscription } = {};
    private _logger: Toolkit.Logger = new Toolkit.Logger(`Plugin: processes: inj_output_bot:`);
    private _destroyed: boolean = false;
    constructor(private _cdRef: ChangeDetectorRef) {
    }
    ngOnDestroy() {
        this._destroyed = true;
        this._saveState();
        Object.keys(this._subscriptions).forEach((key: string) => {
            this._subscriptions[key].unsubscribe();
        });
    }
    ngAfterViewInit() {
        // Subscription to income events
        this._subscriptions.incomeIPCHostMessage = this.api.getIPC().subscribe((message: any) => {
            if (typeof message !== 'object' && message === null) {
                // Unexpected format of message
                return;
            }
            if (message.streamId !== this.session) {
                // No definition of streamId
                return;
            }
            this._onIncomeMessage(message);
        });
        // Subscribe to sessions events
        this._subscriptions.onSessionChange = this.sessions.subscribe().onSessionChange(this._onSessionChange.bind(this));
        this._subscriptions.onSessionOpen = this.sessions.subscribe().onSessionOpen(this._onSessionOpen.bind(this));
        this._subscriptions.onSessionClose = this.sessions.subscribe().onSessionClose(this._onSessionClose.bind(this));
        // Restore state
        this._loadState();
    }
    public _ng_onKeyUp(event: KeyboardEvent) {
        if (this._ng_working) {
            this._sendInput(event);
        } else {
            this._sendCommand(event);
        }
    }
    public _ng_onStop(event: MouseEvent) {
        this._sendStop();
    }
    private _sendCommand(event: KeyboardEvent) {
        if (event.key !== 'Enter') {
            return;
        }
        if (this._ng_cmd.trim() === '') {
            return;
        }
        this.api.getIPC().request({
            stream: this.session,
            command: EHostCommands.command,
            cmd: this._ng_cmd,
            shell: this._ng_settings.shell,
        }, this.session).catch((error: Error) => {
            console.error(error);
        });
    }
    private _sendStop() {
        if (!this._ng_working) {
            return;
        }
        this.api.getIPC().request({
            stream: this.session,
            command: EHostCommands.stop,
        }, this.session).catch((error: Error) => {
            console.error(error);
        });
    }
    private _sendInput(event: KeyboardEvent) {
        this.api.getIPC().request({
            stream: this.session,
            command: EHostCommands.write,
            input: event.key
        }, this.session).catch((error: Error) => {
            console.error(error);
        });
        this._ng_cmd = '';
    }
    private _onIncomeMessage(message: any) {
        if (typeof message.event === 'string') {
            // Process events
            return this._onIncomeEvent(message);
        }
    }
    private _onIncomeEvent(message: any) {
        switch (message.event) {
            case EHostEvents.ForkStarted:
                this._ng_working = true;
                break;
            case EHostEvents.ForkClosed:
                this._ng_working = false;
                this._ng_cmd = '';
                break;
            case EHostEvents.SettingsUpdated:
                this._ng_settings = message.settings;
                this._settingsUpdated();
                break;
        }
        this._forceUpdate();
    }
    private _settingsUpdated(settings?: IForkSettings) {
        if (settings !== undefined) {
            this._ng_settings = settings;
        }
        if (this._ng_settings === undefined) {
            return;
        }
        this._ng_envvars = [];
        Object.keys(this._ng_settings.env).forEach((key: string) => {
            this._ng_envvars.push({
                key: key,
                value: this._ng_settings.env[key]
            });
        });
        this._forceUpdate();
    }
    private _onSessionChange(guid: string) {
        this._saveState();
        this.session = guid;
        this._loadState();
    }
    private _onSessionOpen(guid: string) {
        //
    }
    private _onSessionClose(guid: string) {
        //
    }
    private _saveState() {
        if (this._ng_envvars.length === 0) {
            // Do not save, because data wasn't gotten from backend
            return;
        }
        state.save(this.session, {
            _ng_envvars: this._ng_envvars,
            _ng_settings: this._ng_settings,
            _ng_working: this._ng_working,
            _ng_cmd: this._ng_cmd === undefined ? '' : this._ng_cmd,
        });
    }
    private _loadState() {
        this._ng_envvars  = [];
        this._ng_settings = undefined;
        this._ng_working = false;
        this._ng_cmd = '';
        const stored: IState | undefined = state.load(this.session);
        if (stored === undefined) {
            this._initState();
        } else {
            Object.keys(stored).forEach((key: string) => {
                (this as any)[key] = stored[key];
            });
        }
        if (this._ng_input !== null && this._ng_input !== undefined) {
            this._ng_input.nativeElement.value = this._ng_cmd;
        }
        this._forceUpdate();
    }
    private _initState() {
        // Request current settings
        this.api.getIPC().request({
            stream: this.session,
            command: EHostCommands.getSettings,
        }, this.session).then((response) => {
            this._settingsUpdated(response.settings);
        });
        // Request current cwd
        this.api.getIPC().request({
            stream: this.session,
            command: EHostCommands.getSettings,
        }, this.session).then((response) => {
            this._forceUpdate();
        }).catch((error: Error) => {
            this._logger.env(`Cannot get current setting. It could be stream just not created yet. Error message: ${error.message}`);
        });
    }
    private _forceUpdate() {
        if (this._destroyed) {
            return;
        }
        this._cdRef.detectChanges();
    }
}
</code></pre>
</div>
<div id="shr_styles.less" class="tabcontent shr">
<pre><code class="language-CSS">
@import '../../../../../../theme/variables.less';
:host {
    position: absolute;
    display: block;
    top:0.5rem;
    left:0.5rem;
    right: 0.5rem;
    bottom: 0.5rem;
    overflow-x: hidden;
    overflow-y: auto;
    & * {
        color: @scheme-color-0;
    }
    & div.wrapper{
        position: relative;
        display: block;
        width: 100%;
        & ul.env-vars{
            position: relative;
            display: block;
            padding: 0;
            margin: 0;
            list-style: none;
            max-height: 15rem;
            overflow-x: hidden;
            overflow-y: auto;
            & li{
                position: relative;
                display: block;
                padding: 0;
                margin: 0;
                list-style: none;
                height: 1rem;
                white-space: nowrap;
                border-bottom: thin dotted grey;
                & * {
                    display: inline-block;
                    vertical-align: top;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }
                & span.key{
                    width: 30%;
                }
                & span.value{
                    width: 70%;
                }
            }
        }
        & p.crop{
            font-size: 0.8rem;
            line-height: 0.8rem;
            font-family: 'console', monospace;
            height: 1rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: pre;
        }
    }
    & .container{
        position: relative;
        display: block;
        box-sizing: border-box;
        width: 100%;
        overflow: hidden;
        & div.input-wrapper {
            position: relative;
            display: block;
            height: 1.5rem;
            width: ~"calc(100% + 1rem)";
            margin-left: -0.5rem;
        }
        &.working{
            & div.input-wrapper {
                position: relative;
                display: block;
                height: 1.5rem;
                width: ~"calc(100% - 5.5rem)";
                margin-left: 2.5rem;
            }
            & .input-area{
                width: auto;
                margin-right: 2.5rem;
            }
        }
        & div.spinner{
            position: absolute;
            left: 0.25rem;
            top: 0.25rem;
            width: 2rem;
            height: 1rem;
        }
        & div.buttons{
            position: absolute;
            right: 0;
            top: -0.35rem;
            height: 100%;
            width: 3rem;
        }
    }
}
</code></pre>
</div>
<div id="shr_template.html" class="tabcontent shr">
<pre><code class="language-HTML">&lt;div class="wrapper" *ngIf="_ng_settings !== undefined"&gt;
    &lt;p class="t-normal"&gt;Environment vars&lt;/p&gt;
    &lt;ul class="env-vars"&gt;
        &lt;li *ngFor="let envvar of _ng_envvars"&gt;
            &lt;span class="key t-console"&gt;{{envvar.key}}&lt;/span&gt;
            &lt;span class="value t-console"&gt;{{envvar.value}}&lt;/span&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p class="t-normal"&gt;Shell&lt;/p&gt;
    &lt;p class="t-console crop"&gt;{{_ng_settings.shell}}&lt;/p&gt;
    &lt;p class="t-normal"&gt;Cwd&lt;/p&gt;
    &lt;p class="t-console crop"&gt;{{_ng_settings.cwd}}&lt;/p&gt;
&lt;/div&gt;
&lt;div [attr.class]="'container ' + (_ng_working ? 'working' : 'free')"&gt;
    &lt;div class="comstyle-input-holder input-wrapper"&gt;
        &lt;div class="comstyle-input"&gt;
            &lt;input #cmdinput
                class="comstyle-input"
                [attr.disabled]="_ng_working ? '' : null"
                type="text"
                placeholder="command or path to program to be executed"
                [(ngModel)]="_ng_cmd" 
                (keyup)="_ng_onKeyUp($event)"/&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="buttons" *ngIf="_ng_working"&gt;
        &lt;span class="small-button" (click)="_ng_onStop($event)"&gt;Stop&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="spinner" *ngIf="_ng_working"&gt;
        &lt;lib-primitive-spinner-regular&gt;&lt;/lib-primitive-spinner-regular&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
</div>
<h1 id="additional-features"><a class="header" href="#additional-features">Additional features</a></h1>
<p>In this part a few additional features will be explained with an example as well as a line by line description of the example code.</p>
<h2 id="popup"><a class="header" href="#popup">Popup</a></h2>
<p>A popup is a window that appears on the most upper layer of Chipmunk and blocks any kind of interaction outside of the popup until closed. It can be closed by either clicking the 'x' button on the upper right
To create and remove popups, the <a href="02_extensions/05_api.html#api"><code>API</code></a> is required. <strong>Chipmunk</strong> provides an <a href="02_extensions/05_api.html#api"><code>API</code></a> which gives access to major core events and different modules. The <a href="02_extensions/05_api.html#api"><code>API</code></a> for the <strong>UI</strong> is named <code>chipmunk.client.toollkit</code>.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>In this example, a plugin with a button will be created. When the button is pressed, a popup with a message (provided by the plugin) will be shown along with a button to close the popup window.</p>
<p><strong>Popup component</strong></p>
<div class="tab popup">
  <button class="tablinks" onclick="openCode(event, 'popup_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'popup_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'popup_component.ts')">component.ts</button>
</div>
<div id="popup_template.html" class="tabcontent popup">
<pre><code class="language-HTML">&lt;p&gt;{{msg}}&lt;/p&gt;  &lt;!-- Show message from component --&gt;
</code></pre>
</div>
<div id="popup_styles.less" class="tabcontent popup">
<pre><code class="language-CSS">p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="popup_component.ts" class="tabcontent popup active">
<pre><code class="language-Javascript">import { Component, Input } from '@angular/core';   // Import necessary components for popup
@Component({
    selector: 'example-popup-com',                  // Choose the selector name of the popup
    templateUrl: './template.html',                 // Assign HTML file as template
    styleUrls: ['./styles.less']                    // Assign LESS file as style sheet file})
export class PopupComponent {
    @Input() public msg: string;                    // Expect input from host component
    constructor() { }
}
</code></pre>
</div>
<p><strong>Plugin component</strong></p>
<div class="tab ppopup">
  <button class="tablinks" onclick="openCode(event, 'ppopup_plugin_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'ppopup_plugin_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'ppopup_plugin_component.ts')">component.ts</button>
</div>
<div id="ppopup_plugin_template.html" class="tabcontent ppopup">
<pre><code class="language-HTML">&lt;p&gt;Example&lt;/p&gt;
&lt;button (click)=&quot;_ng_popup()&quot;&gt;&lt;/button&gt;   &lt;!-- Button to open popup --&gt;
</code></pre>
</div>
<div id="ppopup_plugin_styles.less" class="tabcontent ppopup">
<pre><code class="language-CSS">p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="ppopup_plugin_component.ts" class="tabcontent ppopup active">
<pre><code class="language-Javascript">import { Component, Input } from '@angular/core';       // Import necessary components for plugin
import { PopupComponent } from './popup/components';    // Import the popup module
@Component({
    selector: 'example',                                // Choose the selector name of the popup
    templateUrl: './template.html',                     // Assign HTML file as template
    styleUrls: ['./styles.less']                        // Assign LESS file as style sheet file})
export class ExampleComponent {
    @Input() public api: Toolkit.IAPI;                  // API assignment
    @Input() public msg: string;                        // Expect input from host component
    constructor() { }
    public _ng_popup() {
        this.api.addPopup({
            caption: 'Example',
            component: {
                factory: PopupComponent,                // Assign the popup module to factory
                inputs: {
                    msg: 'Hello World!',                // Provide the popup with a message as input
                }
            },
            buttons: [                                  // Create a button on the popup to close it
                {
                    caption: 'Cancel',
                    handler: () => {
                        this.api.removePopup();         // Close popup
                    }
                }
            ]
        });
    }
}
</code></pre>
</div>
<blockquote>
<p>NOTE: For more information how the <code>API</code> works check out <a href="02_extensions/05_api.html#api"><code>Chapter 5 - API</code></a></p>
</blockquote>
<h2 id="notifications"><a class="header" href="#notifications">Notifications</a></h2>
<p>To create notifications, the <a href="02_extensions/05_api.html#api"><code>API</code></a> is required. <strong>Chipmunk</strong> provides an <a href="02_extensions/05_api.html#api"><code>API</code></a> which gives access to major core events and different modules. The <a href="02_extensions/05_api.html#api"><code>API</code></a> for the <strong>UI</strong> is named <code>chipmunk.client.toollkit</code>.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>The following example shows an example plugin with a line of text and a button which creates a notification.</p>
<div class="tab not">
  <button class="tablinks" onclick="openCode(event, 'not_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'not_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'not_component.ts')">component.ts</button>
</div>
<div id="not_template.html" class="tabcontent not">
<pre><code class="language-HTML">&lt;p&gt;Example&lt;/p&gt;
&lt;button (click)=&quot;_ng_notify()&quot;&gt;&lt;/button&gt;   &lt;!-- Create a button with a method to be called from the components.ts file --&gt;
</code></pre>
</div>
<div id="not_styles.less" class="tabcontent not">
<pre><code class="language-CSS">p {
    color: #FFFFFF;
}
button {
    height: 20px;
    width: 50px;
}
</code></pre>
</div>
<div id="not_component.ts" class="tabcontent not active">
<pre><code class="language-Javascript">import { Component } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
import { ENotificationType } from 'chipmunk.client.toolkit';    // Import notification type
@Component({
    selector: 'example',                                        // Choose the selector name of the plugin
    templateUrl: './template.html',                             // Assign HTML file as template
    styleUrls: ['./styles.less']                                // Assign LESS file as style sheet file
})
export class ExampleComponent {
    @Input() public api: Toolkit.IAPI;                          // API assignment
    constructor() { }
    public _ng_notify() {
        this.api.addNotification({
            caption: 'Info',                                    // Caption of the notification
            message: 'You just got notified!',                  // Message of the notification
            options: {
                type: ENotificationType.info                    // Notification type
            }
        });
    }
}
</code></pre>
</div>
<blockquote>
<p>NOTE: For more information how the <code>API</code> works check out <a href="02_extensions/05_api.html#api"><code>Chapter 5 - API</code></a></p>
</blockquote>
<h2 id="logger"><a class="header" href="#logger">Logger</a></h2>
<p>To use the logger, the <a href="02_extensions/05_api.html#api"><code>API</code></a> is required. <strong>Chipmunk</strong> provides an <a href="02_extensions/05_api.html#api"><code>API</code></a> which gives access to major core events and different modules. The <a href="02_extensions/05_api.html#api"><code>API</code></a> for the <strong>UI</strong> is named <code>chipmunk.client.toollkit</code>.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<p>In the example below a plugin is created which logs a message as soon as the plugin is created.</p>
<div class="tab log">
  <button class="tablinks" onclick="openCode(event, 'log_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'log_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'log_component.ts')">component.ts</button>
</div>
<div id="log_template.html" class="tabcontent log">
<pre><code class="language-HTML">&lt;p&gt;Example&lt;/p&gt;     &lt;!-- Create a line of text --&gt;
</code></pre>
</div>
<div id="log_styles.less" class="tabcontent log">
<pre><code class="language-CSS">p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="log_component.ts" class="tabcontent log active">
<pre><code class="language-Javascript">import { Component } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',                                                        // Choose the selector name of the plugin
    templateUrl: './template.html',                                             // Assign HTML file as template
    styleUrls: ['./styles.less']                                                // Assign LESS file as style sheet file})
export class ExampleComponent {
    private _logger: Toolkit.Logger = new Toolkit.Logger('Plugin: example: ');  // Instantiate logger with signature
    constructor() {
        this._logger.debug('Plugin started!');                                  // Create debug message
    }
}
</code></pre>
</div>
<blockquote>
<p>NOTE: For more information how the <code>API</code> works check out <a href="02_extensions/05_api.html#api"><code>Chapter 5 - API</code></a></p>
</blockquote>
<h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<h2 id="debugging-in-the-ui-part"><a class="header" href="#debugging-in-the-ui-part">Debugging in the UI part</a></h2>
<p>The developer mode can be very helpful at developing (especially for the development in the <strong>UI</strong>). To enable the developing mode, type the following command in the command line, in which the application is started:</p>
<p><code>export CHIPMUNK_DEVELOPING_MODE=ON</code></p>
<p>The developer mode will create a debugger console with which console outputs made in the <strong>UI</strong> can be seen.</p>
<p>Another feature which the debugger provides is creating breakpoints as well as the ability to select HTML elements which then will be highlighted in the code along with its attributes.</p>
<blockquote>
<p>NOTE: The keyword <code>debugger</code> serves as a breakpoint in the UI part.</p>
</blockquote>
<h2 id="debugging-in-the-process-part"><a class="header" href="#debugging-in-the-process-part">Debugging in the process part</a></h2>
<p>To debug in the process part, simply put breakpoints in the <code>.js</code> files located in the folder  <code>releases</code> from <code>Chipmunk Quickstart</code></p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<p>In the example below a plugin is created which has a breakpoint in the constructor, so the application stops as soon as the application is created.</p>
<div class="tab dev">
  <button class="tablinks" onclick="openCode(event, 'dev_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'dev_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'dev_component.ts')">component.ts</button>
</div>
<div id="dev_template.html" class="tabcontent dev">
<pre><code class="language-HTML">&lt;p&gt;Example&lt;/p&gt;
</code></pre>
</div>
<div id="dev_styles.less" class="tabcontent dev">
<pre><code class="language-CSS">p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="dev_component.ts" class="tabcontent dev active">
<pre><code class="language-Javascript">import { Component } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',                            // Choose the selector name of the plugin
    templateUrl: './template.html',                 // Assign HTML file as template
    styleUrls: ['./styles.less']                    // Assign LESS file as style sheet file})
export class ExampleComponent {
    constructor() {
        console.log('Stop after!');                 // Console output to see where the breakpoint will appear
        debugger;                                   // Creating a breakpoint in the constructor
    }
}
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" type="text/css" href="../styles/styles.extension.css">
<script src="../scripts/script.tab.js">
</script>
<h1 id="api"><a class="header" href="#api">API</a></h1>
<p>Chipmunk provides an <code>API</code> for the <strong>UI</strong>, which gives access to major core events, UI of the core and plugin IPC (required for communication beteween the host and render of plugin). The <code>API</code> for the <strong>UI</strong> is named <code>chipmunk.client.toollkit</code> and holds different modules.</p>
<blockquote>
<p><strong>NOTE:</strong> This API will soon be deprecated</p>
</blockquote>
<h2 id="howAPI"><a class="header" href="#howAPI">1. How to use the API</a></h2>
<h3 id="api1"><a class="header" href="#api1"> Method 1: Bind the api to the component </a></h3>
<p>One way to use the API is by binding it to the main component of the plugin (<code>component.ts</code>).</p>
<blockquote>
<p><strong>IMPORTANT</strong>: When the <code>API</code> is bound to component directly, the <code>API</code> is bound to the life cycle of the component and gets destroyed together with the component. It is advised to bind the <code>API</code> to the component if it is going to be used locally only by the component itself and nothing else. If the <code>API</code> should be used globally (in scope of the plugin), the second method is more suited.</p>
</blockquote>
<p>The example code below shows an example plugin with the API bound to it. The example also includes three methods that are being called upon specific events from the sessions/tabs. To demonstrate how to use the <code>API</code>, each time the session changes the session ID will be printed out in the console.</p>
<div class="tab api">
  <button class="tablinks" onclick="openCode(event, 'api_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'api_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'api_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'api_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'api_public_api.ts')">public_api.ts</button>
</div>
<div id="api_template.html" class="tabcontent api">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;
</code></pre>
</div>
<div id="api_styles.less" class="tabcontent api">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="api_component.ts" class="tabcontent api active">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',                                                                                                // Choose the selector name of the plugin
    templateUrl: './template.html',                                                                                     // Assign HTML file as template
    styleUrls: ['./styles.less']                                                                                        // Assign LESS file as style sheet file})
})
export class ExampleComponent {
    @Input() public api: Toolkit.IAPI;                                                                                  // API assignment
    @Input() public session: string;                                                                                    // [optional] Session ID assignment
    @Input() public sessions: Toolkit.ControllerSessionsEvents;                                                         // [optional] Session event listener assignment
    private _subs: { [key: string]: Toolkit.Subscription } = {};                                                        // [optional] Hashlist for session events
    constructor() {
        this._subs.onSessionChange = this.sessions.subscribe().onSessionChange(this._onSessionChange.bind(this));       // [optional] Subscribe to session change event
        this._subs.onSessionOpen = this.sessions.subscribe().onSessionOpen(this._onSessionOpen.bind(this));             // [optional] Subscribe to new session open event
        this._subs.onSessionClose = this.sessions.subscribe().onSessionClose(this._onSessionClose.bind(this));          // [optional] Subscribe to session close event
    }
    private _onSessionChange(session: string) {                                                                         // [optional] Method when session changes
        this.session = session;                                                                                         // Reassign the session to the session, to which has been changed to
        console.log(`Session id: ${this.api.getActiveSessionId()}`);                                                    // Print session ID in the console when the session changes
    }
    private _onSessionOpen(session: string) { }                                                                         // [optional] Method when new session opens
    private _onSessionClose(session: string) { }                                                                        // [optional] Method when session closes
}
</code></pre>
</div>
<div id="api_module.ts" class="tabcontent api">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                   // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';             // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';         // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                     // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                           // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                           // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {  // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');       // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="api_public_api.ts" class="tabcontent api">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>
<blockquote>
<p><strong>NOTE</strong>: The lines commented with <em>[optional]</em> will be covered in <a href="02_extensions/04_api.html#cse">ControllerSessionsEvents</a> and serves in this example just for demonstration</p>
</blockquote>
<h3 id="api2"><a class="header" href="#api2"> Method 2: Create a service for the api</a></h3>
<p>Another way to make use of the <code>API</code> is by creating a service, which can be accessed from any part of the plugin. To make it work, it is important to export the service file in <code>public_api.ts</code>, the library management file of the plugin (generated by Angular automatically).
To demonstrate how to use the <code>API</code>, each time the session changes the session ID will be printed out in the console.</p>
<blockquote>
<p><strong>IMPORTANT</strong>: Compared to the first method, when the <code>API</code> is created in a service file, the <code>API</code> will be accessable globally (in scope of the plugin) and will only get destroyed when the application is closed.</p>
</blockquote>
<div class="tab api2">
  <button class="tablinks" onclick="openCode(event, 'api2_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'api2_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'api2_service.ts')">service.ts</button>
  <button class="tablinks" onclick="openCode(event, 'api2_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'api2_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'api2_public_api.ts')">public_api.ts</button>
</div>
<div id="api2_template.html" class="tabcontent api2">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;
</code></pre>
</div>
<div id="api2_styles.less" class="tabcontent api2">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="api2_service.ts" class="tabcontent api2 active">
<pre><code class="language-Javascript">
import * as Toolkit from 'chipmunk.client.toolkit';
export class Service extends Toolkit.PluginService {                                                                                // The service class has to inherit the PluginService from chipmunk.client.toolkit to get access the the API methods
    private api: Toolkit.IAPI | undefined;                                                                                          // Instance variable to assign API
    private session: string;                                                                                                        // [optional] 
    private _subs: { [key: string]: Toolkit.Subscription } = {};                                                                    // [optional] Hashlist of subscriptions for API
    constructor() {
        super();                                                                                                                    // Call parent constructor
        this._subs.onReady = this.onAPIReady.subscribe(this._onReady.bind(this));                                                   // Subscribe to the onAPIReady method from the API to see when the API is ready
    }
    private _onReady() {                                                                                                            // Method to be called when the API is ready
        this.api = this.getAPI();                                                                                                   // Assign the API to instance variable
        if (this.api === undefined) {                                                                                               // Check if the API is defined to prevent errors
            console.log('API not defined!');
            return;
        }
        this._subs.onSessionOpen = this.api.getSessionsEventsHub().subscribe().onSessionOpen(this._onSessionOpen.bind(this));       // [optional] Subscribe to session change event
        this._subs.onSessionClose = this.api.getSessionsEventsHub().subscribe().onSessionClose(this._onSessionClose.bind(this));    // [optional] Subscribe to new session open event
        this._subs.onSessionChange = this.api.getSessionsEventsHub().subscribe().onSessionChange(this._onSessionChange.bind(this)); // [optional] Subscribe to session close event
    }
    private _onSessionChange(session: string) {                                                                                     // [optional] Method when session changes
        this.session = session;                                                                                                     // Reassign the session to the session, to which has been changed to
        console.log(`Session id: ${this.api.getActiveSessionId()}`);                                                                // Print session ID in the console when the session changes
    }
    private _onSessionOpen(session: string) { }                                                                                     // [optional] Method when new session opens
    private _onSessionClose(session: string) { }                                                                                    // [optional] Method when session closes
}
export default (new Service());                                                                                                     // Export the instantiated service class
</code></pre>
</div>
<div id="api2_component.ts" class="tabcontent api2">
<p><strong>NOTE:</strong>The lines commented with <strong>[optional]</strong> will be covered in <a href="02_extensions/04_api.html#cse">ControllerSessionsEvents</a> and serves in this example just for demonstration</p>
<pre><code class="language-Javascript">
import { Component } from '@angular/core';
@Component({
    selector: 'example',                // Choose the selector name of the plugin
    templateUrl: './template.html',     // Assign HTML file as template
    styleUrls: ['./styles.less']        // Assign LESS file as style sheet file})
export class ExampleComponent {
    constructor() { }                   // Constructor not necessary for API assignment
}
</code></pre>
</div>
<div id="api2_module.ts" class="tabcontent api2">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                   // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';             // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';         // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                     // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                           // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                           // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {  // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');       // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="api2_public_api.ts" class="tabcontent api2">
<pre><code class="language-Javascript">
import Service from './service';
export * from './component';
export * from './module';
export { Service };
</code></pre>
</div>
<blockquote>
<p><strong>IMPORTANT</strong>: It's important to note, that the <code>Service</code> HAS to be exported to be used globally (in scope of the plugin)</p>
</blockquote>
<h1 id="api_inter"><a class="header" href="#api_inter"> API - Interfaces</a></h1>
<h2 id="iapi"><a class="header" href="#iapi">2. IAPI interface</a></h2>
<pre><code class="language-Javascript">// Typescript

export interface IAPI {
    /**
     * @returns {PluginIPC} Returns PluginAPI object for host and render plugin communication
     */
    getIPC: () =&gt; PluginIPC | undefined;
    /**
     * @returns {string} ID of active stream (active tab)
     */
    getActiveSessionId: () =&gt; string;
    /**
     * Returns hub of viewport events (resize, update and so on)
     * Should be used to track state of viewport
     * @returns {ControllerViewportEvents} viewport events hub
     */
    getViewportEventsHub: () =&gt; ControllerViewportEvents;
    /**
     * Returns hub of sessions events (open, close, changed and so on)
     * Should be used to track active sessions
     * @returns {ControllerSessionsEvents} sessions events hub
     */
    getSessionsEventsHub: () =&gt; ControllerSessionsEvents;
    /**
     * Open popup
     * @param {IPopup} popup - description of popup
     */
    addPopup: (popup: IPopup) =&gt; string;
    /**
     * Closes popup
     * @param {string} guid - id of existing popup
     */
    removePopup: (guid: string) =&gt; void;
    /**
     * Adds sidebar title injection.
     * This method doesn't need "delete" method, because sidebar injection would be
     * removed with a component, which used as sidebar tab render.
     * In any way developer could define an argument as "undefined" to force removing
     * injection from the title of sidebar
     * @param {IComponentDesc} component - description of Angular component
     * @returns {void}
     */
    setSidebarTitleInjection: (component: IComponentDesc | undefined) =&gt; void;
    /**
     * Opens sidebar app by ID
     * @param {string} appId - id of app
     * @param {boolean} silence - do not make tab active
     */
    openSidebarApp: (appId: string, silence: boolean) =&gt; void;
    /**
     * Opens toolbar app by ID
     * @param {string} appId - id of app
     * @param {boolean} silence - do not make tab active
     */
    openToolbarApp: (appId: string, silence: boolean) =&gt; void;
    /**
     * Adds new notification
     * @param {INotification} notification - notification to be added
     */
    addNotification: (notification: INotification) =&gt; void;
}
</code></pre>
<h3 id="iapi_getIPC"><a class="header" href="#iapi_getIPC">getIPC</a></h3>
<pre><code class="language-Javascript">    /**
     * @returns {PluginIPC} Returns PluginAPI object for host and render plugin communication
     */
    getIPC: () =&gt; PluginIPC | undefined;
</code></pre>
<h3 id="example---getipc"><a class="header" href="#example---getipc"> Example - getIPC</a></h3>
<p>In this example the <code>API</code> will be assigned to the instance variable of the main component of the plugin</p>
<div class="tab getipc">
  <button class="tablinks" onclick="openCode(event, 'getipc_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'getipc_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'getipc_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'getipc_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'getipc_public_api.ts')">public_api.ts</button>
</div>
<div id="getipc_template.html" class="tabcontent getipc">
<pre><code class="language-HTML">&lt;p&gt;Example&lt;/p&gt;     &lt;!-- Show session ID --&gt;
</code></pre>
</div>
<div id="getipc_styles.less" class="tabcontent getipc">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="getipc_component.ts" class="tabcontent getipc active">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',                                    // Choose the selector name of the plugin
    templateUrl: './template.html',                         // Assign HTML file as template
    styleUrls: ['./styles.less']                            // Assign LESS file as style sheet file
})
export class ExampleComponent {
    @Input() public api: Toolkit.IAPI;                      // API assignment
    public api_copy: Toolkit.IAPI;
    constructor() {
        this.api_copy = this.api.getIPC();                  // Assign API to instance variable
    }
}
</code></pre>
</div>
<div id="getipc_module.ts" class="tabcontent getipc">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                   // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';             // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';         // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                     // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                           // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                           // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {  // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');       // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="getipc_public_api.ts" class="tabcontent getipc">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>
<h3 id="iapi_getActive"><a class="header" href="#iapi_getActive">getActiveSessionId</a></h3>
<pre><code class="language-Javascript">    /**
     * @returns {string} ID of active stream (active tab)
     */
    getActiveSessionId: () =&gt; string;
</code></pre>
<h2 id="example---getactivesessionid"><a class="header" href="#example---getactivesessionid">Example - getActiveSessionId</a></h2>
<p>In this example the session id will be shown in the plugin</p>
<div class="tab asid">
  <button class="tablinks" onclick="openCode(event, 'asid_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'asid_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'asid_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'asid_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'asid_public_api.ts')">public_api.ts</button>
</div>
<div id="asid_template.html" class="tabcontent asid">
<pre><code class="language-HTML">
&lt;p&gt;{{sessionID}}&lt;/p&gt;   &lt;!-- Show session ID --&gt;
</code></pre>
</div>
<div id="asid_styles.less" class="tabcontent asid">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="asid_component.ts" class="tabcontent asid active">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',                                        // Choose the selector name of the plugin
    templateUrl: './template.html',                             // Assign HTML file as template
    styleUrls: ['./styles.less']                                // Assign LESS file as style sheet file
})
export class ExampleComponent {
    @Input() public api: Toolkit.IAPI;                          // API assignment
    public sessionID: string;
    constructor() {
        this.sessionID = this.api.getActiveSessionId();         // Assign session id to local variable
    }
}
</code></pre>
</div>
<div id="asid_module.ts" class="tabcontent asid">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                       // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';                 // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';             // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                         // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                               // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                               // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {      // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');           // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="asid_public_api.ts" class="tabcontent asid">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>
<h3 id="iapi_getVPEH"><a class="header" href="#iapi_getVPEH">getViewportEventsHub</a></h3>
<pre><code class="language-Javascript">    /**
     * Returns hub of viewport events (resize, update and so on)
     * Should be used to track state of viewport
     * @returns {ControllerViewportEvents} viewport events hub
     */
    getViewportEventsHub: () =&gt; ControllerViewportEvents;
</code></pre>
<h3 id="example---getviewporteventshub"><a class="header" href="#example---getviewporteventshub">Example - getViewportEventsHub</a></h3>
<div class="tab vpe">
  <button class="tablinks" onclick="openCode(event, 'vpe_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'vpe_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'vpe_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'vpe_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'vpe_public_api.ts')">public_api.ts</button>
</div>
<div id="vpe_template.html" class="tabcontent vpe">
<pre><code class="language-HTML">
&lt;p #element&gt;Example&lt;/p&gt;     &lt;!-- Create a line of text --&gt;
</code></pre>
</div>
<div id="vpe_styles.less" class="tabcontent vpe">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="vpe_component.ts" class="tabcontent vpe active">
<pre><code class="language-Javascript">
import { Component, Input, ViewChild } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',                                                                                                // Choose the selector name of the plugin
    templateUrl: './template.html',                                                                                     // Assign HTML file as template
    styleUrls: ['./styles.less']                                                                                        // Assign LESS file as style sheet file})
})
export class ExampleComponent {
    @ViewChild('element', {static: false}) _element: HTMLParagraphElement;
    @Input() public api: Toolkit.IAPI;                                                                                  // API assignment
    private _subs: { [key: string]: Toolkit.Subscription } = {};                                                        // Hashlist for subscriptions
    constructor() {
        this._subs.onRowSelected() = this.api.getViewportEventsHub().subscribe().onRowSelected(this._onRow.bind(this)); // Subscribe to the row selection event and call _onRow in case a row is selected
    }
    private _onRow() {
        const selected = this.api.getViewportEventsHub().getSelected();
        this._element.innerHTML = `Line: ${selected.row}: ${selected.str}`;                                             // Reassign the text of the plugin paragraph with the selected line and its text
    }
}
</code></pre>
</div>
<div id="vpe_module.ts" class="tabcontent vpe">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                       // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';                 // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';             // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                         // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                               // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                               // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {      // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');           // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="vpe_public_api.ts" class="tabcontent vpe">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>
<h3 id="getSEH"><a class="header" href="#getSEH">getSessionsEventsHub</a></h3>
<pre><code class="language-Javascript">    /**
     * Returns hub of sessions events (open, close, changed and so on)
     * Should be used to track active sessions
     * @returns {ControllerSessionsEvents} sessions events hub
     */
    getSessionsEventsHub: () =&gt; ControllerSessionsEvents;
</code></pre>
<h3 id="example---getsessionseventshub"><a class="header" href="#example---getsessionseventshub">Example - getSessionsEventsHub</a></h3>
<p>This example shows the usage of <code>getSessionsEventsHub</code> by creating methods to be called when a session <em>opens/closes/changes</em>:</p>
<div class="tab seh">
  <button class="tablinks" onclick="openCode(event, 'seh_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'seh_styles.less')">styles.less</button>
  <button class="tablinks" onclick="openCode(event, 'seh_service.ts')">service.ts</button>
  <button class="tablinks active" onclick="openCode(event, 'seh_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'seh_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'seh_public_api.ts')">public_api.ts</button>
</div>
<div id="seh_template.html" class="tabcontent seh">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;      &lt;!-- Create a line of text --&gt;
</code></pre>
</div>
<div id="seh_styles.less" class="tabcontent seh">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="seh_service.ts" class="tabcontent seh">
<pre><code class="language-Javascript">
import * as Toolkit from 'chipmunk.client.toolkit';
export class Service extends Toolkit.PluginService {                                                                                // The service class has to inherit the PluginService from chipmunk.client.toolkit to get access the the API methods
    private api: Toolkit.IAPI | undefined;                                                                                          // Instance variable to assign API
    private session: string;                                                                                                        // Instance variable to assign session ID 
    private _subs: { [key: string]: Toolkit.Subscription } = {};                                                                    // Hashlist of subscriptions for API
    constructor() {
        super();                                                                                                                    // Call parent constructor
        this._subs.onReady = this.onAPIReady.subscribe(this._onReady.bind(this));                                                   // Subscribe to the onAPIReady method from the API to see when the API is ready
    }
    private _onReady() {                                                                                                            // Method to be called when the API is ready
        this.api = this.getAPI();                                                                                                   // Assign the API to instance variable
        if (this.api === undefined) {                                                                                               // Check if the API is defined to prevent errors
            console.log('API not defined!');
            return;
        }
        this._subs.onSessionOpen = this.api.getSessionsEventsHub().subscribe().onSessionOpen(this._onSessionOpen.bind(this));       // <-- Subscribe to session change event
        this._subs.onSessionClose = this.api.getSessionsEventsHub().subscribe().onSessionClose(this._onSessionClose.bind(this));    // <-- Subscribe to new session open event
        this._subs.onSessionChange = this.api.getSessionsEventsHub().subscribe().onSessionChange(this._onSessionChange.bind(this)); // <-- Subscribe to session close event
    }
    private _onSessionChange(session: string) {                                                                                     // Method when session changes
        this.session = session;                                                                                                     // Reassign the session to the session, to which has been changed to
        console.log(`Session id: ${this.api.getActiveSessionId()}`);                                                                // Print session ID in the console when the session changes
    }
    private _onSessionOpen(session: string) { }                                                                                     // Method when new session opens
    private _onSessionClose(session: string) { }                                                                                    // Method when session closes
}
export default (new Service());                                                                                                     // Export the instantiated service class
</code></pre>
</div>
<div id="seh_component.ts" class="tabcontent seh active">
<pre><code class="language-Javascript">
import { Component } from '@angular/core';
import Service from './service'
@Component({
    selector: 'example',                                                                                                            // Choose the selector name of the plugin
    templateUrl: './template.html',                                                                                                 // Assign HTML file as template
    styleUrls: ['./styles.less']                                                                                                    // Assign LESS file as style sheet file})
export class ExampleComponent {
    constructor() { }
}
</code></pre>
</div>
<div id="seh_module.ts" class="tabcontent seh">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                                                                                           // Import the Angular component that is necessary for the setup below
import { Example } from './component';                                                                                              // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';                                                                                 // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ]                                                                                              // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                                                                                                   // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                                                                                                   // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {                                                                          // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');                                                                               // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="seh_public_api.ts" class="tabcontent seh">
<pre><code class="language-Javascript">
import Service from './service';
export * from './component';
export * from './module';
export { Service };
</code></pre>
</div>
<blockquote>
<p><strong>IMPORTANT</strong>: It's important to note, that the <code>Service</code> <strong>HAS</strong> to be exported to be used globally (in scope of the plugin)</p>
</blockquote>
<h3 id="iapi_addPopup"><a class="header" href="#iapi_addPopup">addPopup</a></h3>
<pre><code class="language-Javascript">    /**
     * Open popup
     * @param {IPopup} popup - description of popup
     */
    addPopup: (popup: IPopup) =&gt; string;
</code></pre>
<h3 id="example---addpopup"><a class="header" href="#example---addpopup">Example - addPopup</a></h3>
<p>To create a popup, a plugin to host the popup and the popup itself have to be defined.</p>
<div class="tab addpop">
  <button class="tablinks" onclick="openCode(event, 'addpop_pop_template.html')">/popup/template.html</button>
  <button class="tablinks" onclick="openCode(event, 'addpop_pop_styles.less')">/popup/styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'addpop_pop_component.ts')">/popup/component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'addpop_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'addpop_styles.less')">styles.less</button>
  <button class="tablinks" onclick="openCode(event, 'addpop_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'addpop_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'addpop_public_api.ts')">public_api.ts</button>
</div>
<div id="addpop_pop_template.html" class="tabcontent addpop">
<pre><code class="language-HTML">
&lt;p&gt;{{msg}}&lt;/p&gt;      &lt;!-- Show message from component --&gt;
</code></pre>
</div>
<div id="addpop_pop_styles.less" class="tabcontent addpop">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="addpop_pop_component.ts" class="tabcontent addpop active">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';           // Import necessary components for popup
@Component({
    selector: 'example-popup-com',                          // Choose the selector name of the popup
    templateUrl: './template.html',                         // Assign HTML file as template
    styleUrls: ['./styles.less']                            // Assign LESS file as style sheet file})
export class PopupComponent {
    constructor() { }
    @Input() public msg: string;                            // Expect input from host component
}
</code></pre>
</div>
<div id="addpop_template.html" class="tabcontent addpop">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;
&lt;button (click)=&quot;_ng_popup()&quot;&gt;&lt;/button&gt;       &lt;!-- Button to open popup --&gt;
</code></pre>
</div>
<div id="addpop_styles.less" class="tabcontent addpop">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="addpop_component.ts" class="tabcontent addpop">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';           // Import necessary components for plugin
import { PopupComponent } from './popup/components';        // Import the popup module
@Component({
    selector: 'example',                                    // Choose the selector name of the popup
    templateUrl: './template.html',                         // Assign HTML file as template
    styleUrls: ['./styles.less']                            // Assign LESS file as style sheet file})
export class ExampleComponent {
    @Input() public api: Toolkit.IAPI;                      // API assignment
    @Input() public msg: string;                            // Expect input from host component
    constructor() { }
    public _ng_popup() {
        this.api.addPopup({
            caption: 'Example',
            component: {
                factory: PopupComponent,                    // Assign the popup module to factory
                inputs: {
                    msg: 'Hello World!',                    // Provide the popup with a message as input
                }
            },
            buttons: []
        });
    }
}
</code></pre>
</div>
<div id="addpop_module.ts" class="tabcontent addpop">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                   // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';             // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';         // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                     // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                           // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                           // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {  // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');       // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="addpop_public_api.ts" class="tabcontent addpop">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>
<h3 id="iapi_rmPop"><a class="header" href="#iapi_rmPop">removePopup</a></h3>
<pre><code class="language-Javascript">    /**
     * Closes popup
     * @param {string} guid - id of existing popup
     */
    removePopup: (guid: string) =&gt; void;
</code></pre>
<h3 id="example---removepopup"><a class="header" href="#example---removepopup">Example - removePopup</a></h3>
<p>To remove the popup, one way is to create a button on the popup, which calls the method to remove the popup upon clicking.</p>
<div class="tab rempop">
  <button class="tablinks" onclick="openCode(event, 'rempop_pop_template.html')">/popup/template.html</button>
  <button class="tablinks" onclick="openCode(event, 'rempop_pop_styles.less')">/popup/styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'rempop_pop_component.ts')">/popup/component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'rempop_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'rempop_styles.less')">styles.less</button>
  <button class="tablinks" onclick="openCode(event, 'rempop_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'rempop_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'rempop_public_api.ts')">public_api.ts</button>
</div>
<div id="rempop_pop_template.html" class="tabcontent rempop">
<pre><code class="language-HTML">
&lt;p&gt;{{msg}}&lt;/p&gt;      &lt;!-- Show message from component --&gt;
</code></pre>
</div>
<div id="rempop_pop_styles.less" class="tabcontent rempop">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="rempop_pop_component.ts" class="tabcontent rempop active">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';           // Import necessary components for popup
@Component({
    selector: 'example-popup-com',                          // Choose the selector name of the popup
    templateUrl: './template.html',                         // Assign HTML file as template
    styleUrls: ['./styles.less']                            // Assign LESS file as style sheet file})
export class PopupComponent {
    constructor() { }
    @Input() public msg: string;                            // Expect input from host component
}
</code></pre>
</div>
<div id="rempop_template.html" class="tabcontent rempop">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;
&lt;button (click)=&quot;_ng_popup()&quot;&gt;&lt;/button&gt;       &lt;!-- Button to open popup --&gt;
</code></pre>
</div>
<div id="rempop_styles.less" class="tabcontent rempop">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="rempop_component.ts" class="tabcontent rempop">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';           // Import necessary components for plugin
import { PopupComponent } from './popup/components';        // Import the popup module
@Component({
    selector: 'example',                                    // Choose the selector name of the popup
    templateUrl: './template.html',                         // Assign HTML file as template
    styleUrls: ['./styles.less']                            // Assign LESS file as style sheet file})
export class ExampleComponent {
    @Input() public api: Toolkit.IAPI;                      // API assignment
    @Input() public msg: string;                            // Expect input from host component
    constructor() { }
    public _ng_popup() {
        this.api.addPopup({
            caption: 'Example',
            component: {
                factory: PopupComponent,                    // Assign the popup module to factory
                inputs: {
                    msg: 'Hello World!',                    // Provide the popup with a message as input
                }
            },
            buttons: [                                      // Create a button on the popup to close it
                {
                    caption: 'close',
                    handler: () => {
                        this.api.removePopup();             // close and remove popup
                    }
                }
            ]
        });
    }
}
</code></pre>
</div>
<div id="rempop_module.ts" class="tabcontent rempop">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                   // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';             // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';         // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                     // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                           // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                           // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {  // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');       // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="rempop_public_api.ts" class="tabcontent rempop">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>
<h3 id="iapi_title"><a class="header" href="#iapi_title">setSidebarTitleInjection</a></h3>
<pre><code class="language-Javascript">    /**
     * Adds sidebar title injection.
     * This method doesn't need "delete" method, because sidebar injection would be
     * removed with a component, which used as sidebar tab render.
     * In any way developer could define an argument as "undefined" to force removing
     * injection from the title of sidebar
     * @param {IComponentDesc} component - description of Angular component
     * @returns {void}
     */
    setSidebarTitleInjection: (component: IComponentDesc | undefined) =&gt; void;
</code></pre>
<h3 id="example---setsidebartitleinjection"><a class="header" href="#example---setsidebartitleinjection">Example - setSidebarTitleInjection</a></h3>
<p>In this example a button will be created in the title of the sidebar which will log a message when clicked.</p>
<div class="tab title">
  <button class="tablinks" onclick="openCode(event, 'title_template.html')">/title/template.html</button>
  <button class="tablinks" onclick="openCode(event, 'title_styles.less')">/title/styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'title_component.ts')">/title/component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'title_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'title_styles.less')">styles.less</button>
  <button class="tablinks" onclick="openCode(event, 'title_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'title_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'title_public_api.ts')">public_api.ts</button>
</div>
<div id="title_template.html" class="tabcontent title">
<pre><code class="language-HTML">
&lt;!-- Create the title component of the button. --&gt;
&lt;span&gt;+&lt;/span&gt;      &lt;!-- Create '+' as button --&gt;
</code></pre>
</div>
<div id="title_styles.less" class="tabcontent title">
<pre><code class="language-CSS">
span {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="title_component.ts" class="tabcontent title active">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'lib-add',
    templateUrl: './template.html',
    styleUrls: ['./styles.less']
})
export class ExampleTitleComponent {
    @Input() public _ng_click: () => void;      // Take method from host component and execute when clicked
}
</code></pre>
</div>
<div id="title_template.html" class="tabcontent title">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;      &lt;!-- Show example string --&gt;
</code></pre>
</div>
<div id="title_styles.less" class="tabcontent title">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="title_component.ts" class="tabcontent title">
<pre><code class="language-Javascript">
import { Component, AfterViewInit } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',                                        // Choose the selector name of the plugin
    templateUrl: './template.html',                             // Assign HTML file as template
    styleUrls: ['./styles.less']                                // Assign LESS file as style sheet file
})
export class ExampleComponent implements AfterViewInit {
    @Input() public api: Toolkit.IAPI;                          // API assignment
    ngAfterViewInit() {
        this.api.setSidebarTitleInjection({                     // Create button in title
            factory: ExampleTitleComponent,                     // Assign component for button
            inputs: {
                _ng_click: () => { console.log('Clicked!') },   // Provide function, which logs a string in console, as input
            }
        });
    }
}
</code></pre>
</div>
<div id="title_module.ts" class="tabcontent title">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                       // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';                 // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';             // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                         // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                               // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                               // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {      // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');           // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="title_public_api.ts" class="tabcontent title">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>
<h3 id="iapi_osa"><a class="header" href="#iapi_osa">openSidebarApp</a></h3>
<pre><code class="language-Javascript">    /**
     * Opens sidebar app by ID
     * @param {string} appId - id of app
     * @param {boolean} silence - do not make tab active
     */
    openSidebarApp: (appId: string, silence: boolean) =&gt; void;
</code></pre>
<h3 id="example---opensidebarapp"><a class="header" href="#example---opensidebarapp">Example - openSidebarApp</a></h3>
<p>In this example the plugin <code>serial</code> will be opened and set as the active plugin 2 seconds after the <code>example</code> plugin is opened.</p>
<div class="tab osa">
  <button class="tablinks" onclick="openCode(event, 'osa_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'osa_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'osa_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'osa_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'osa_public_api.ts')">public_api.ts</button>
</div>
<div id="osa_template.html" class="tabcontent osa">
<pre><code class="language-HTML">
&lt;p&gt;Wait for it...&lt;/p&gt;       &lt;!-- Show example string --&gt;
</code></pre>
</div>
<div id="osa_styles.less" class="tabcontent osa">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="osa_component.ts" class="tabcontent osa active">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',                                        // Choose the selector name of the plugin
    templateUrl: './template.html',                             // Assign HTML file as template
    styleUrls: ['./styles.less']                                // Assign LESS file as style sheet file
})
export class ExampleComponent {
    @Input() public api: Toolkit.IAPI;                          // API assignment
    constructor() {
        setTimeout(() => {                                      // Set a timeout of 2000 ms before opening the plugin
            this.api.openSidebarApp('serial', false);           // Open the serial plugin and set it as the active plugin 
        }, 2000);
    }
}
</code></pre>
</div>
<div id="osa_module.ts" class="tabcontent osa">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                       // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';                 // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';             // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                         // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                               // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                               // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {      // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');           // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="osa_public_api.ts" class="tabcontent osa">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>
<h3 id="iapi_ota"><a class="header" href="#iapi_ota">openToolbarApp</a></h3>
<pre><code class="language-Javascript">    /**
     * Opens toolbar app by ID
     * @param {string} appId - id of app
     * @param {boolean} silence - do not make tab active
     */
    openToolbarApp: (appId: string, silence: boolean) =&gt; void;
</code></pre>
<h3 id="example---opentoolbarapp"><a class="header" href="#example---opentoolbarapp">Example - openToolbarApp</a></h3>
<p>In this example the <code>xterminal</code> app will be opened and set as active 2 seconds after the <code>example</code> plugin is opened.</p>
<div class="tab ota">
  <button class="tablinks" onclick="openCode(event, 'ota_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'ota_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'ota_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'ota_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'ota_public_api.ts')">public_api.ts</button>
</div>
<div id="ota_template.html" class="tabcontent ota">
<pre><code class="language-HTML">
&lt;p&gt;Wait for it...&lt;/p&gt;       &lt;!-- Show example string --&gt;
</code></pre>
</div>
<div id="ota_styles.less" class="tabcontent ota">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="ota_component.ts" class="tabcontent ota active">
<pre><code class="language-Javascript">
import { Component, Input, AfterViewInit } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',                                        // Choose the selector name of the plugin
    templateUrl: './template.html',                             // Assign HTML file as template
    styleUrls: ['./styles.less']                                // Assign LESS file as style sheet file
})
export class ExampleComponent implements AfterViewInit {
    @Input() public api: Toolkit.IAPI;                          // API assignment
    constructor() {
        setTimeout(() => {                                      // Set a timeout of 2000 ms before opening the app
            this.api.openToolbarApp('xterminal', false);        // Open the xterminal app and set it as active
        }, 2000);
    }
}
</code></pre>
</div>
<div id="ota_module.ts" class="tabcontent ota">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                       // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';                 // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';             // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                         // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                               // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                               // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {      // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');           // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="ota_public_api.ts" class="tabcontent ota">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>
<h3 id="iapi_addNot"><a class="header" href="#iapi_addNot">addNotification</a></h3>
<pre><code class="language-Javascript">    /**
     * Adds new notification
     * @param {INotification} notification - notification to be added
     */
    addNotification: (notification: INotification) =&gt; void;
</code></pre>
<h3 id="example---addnotification"><a class="header" href="#example---addnotification">Example - addNotification</a></h3>
<p>In this example the <code>xterminal</code> app will be opened and set as active 2 seconds after the <code>example</code> plugin is opened.</p>
<p>The following example shows an example plugin with a line of text and a button which creates a notification.</p>
<div class="tab not">
  <button class="tablinks" onclick="openCode(event, 'not_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'not_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'not_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'not_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'not_public_api.ts')">public_api.ts</button>
</div>
<div id="not_template.html" class="tabcontent not">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;                                                  &lt;!-- Create a line of text --&gt;
&lt;button (click)=&quot;_ng_notify()&quot;&gt;&lt;/button&gt;              &lt;!-- Create a button with a method to be called from the components.ts file --&gt;
</code></pre>
</div>
<div id="not_styles.less" class="tabcontent not">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
button {
    height: 20px;
    width: 50px;
}
</code></pre>
</div>
<div id="not_component.ts" class="tabcontent not active">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
import { ENotificationType } from 'chipmunk.client.toolkit';    // Import notification type
@Component({
    selector: 'example',                                        // Choose the selector name of the plugin
    templateUrl: './template.html',                             // Assign HTML file as template
    styleUrls: ['./styles.less']                                // Assign LESS file as style sheet file
})
export class ExampleComponent {
    @Input() public api: Toolkit.IAPI;                          // API assignment
    public _ng_notify() {
        this.api.addNotification({
            caption: 'Info',                                    // Caption of the notification
            message: 'You just got notified!',                  // Message of the notification
            options: {
                type: ENotificationType.info                    // Notification type
            }
        });
    }
}
</code></pre>
</div>
<div id="not_module.ts" class="tabcontent not">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                       // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';                 // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';             // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                         // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                               // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                               // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {      // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');           // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="not_public_api.ts" class="tabcontent not">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>
<h1 id="abstract"><a class="header" href="#abstract">3. Abstract classes</a></h1>
<p><code>chipmunk.client.toolkit</code> provides different kinds of abstract classes from which classes can extend from.</p>
<h2 id="parsers"><a class="header" href="#parsers">3.1 Parsers</a></h2>
<p>These abstract classes allow to create <strong>parsers</strong> that can modify the output in the rows (e.g: change text color, convert into different format).</p>
<div class="table-wrapper"><table><thead><tr><th>Parser name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="02_extensions/04_api.html#rbp"><code>RowBoundParser</code></a></td><td>Parse only data received from the process part of the plugin</td></tr>
<tr><td><a href="02_extensions/04_api.html#rcp"><code>RowCommomParser</code></a></td><td>Parse data from any kind of source</td></tr>
<tr><td><a href="02_extensions/04_api.html#rtp"><code>RowTypedParser</code></a></td><td>Parse only specific type of source (e.g. DLT)</td></tr>
<tr><td><a href="02_extensions/04_api.html#sp"><code>SelectionParser</code> (coming soon)</a></td><td>Parse only selected line(s), right-click to see self-chosen name as option to see the parsed result in the tab <strong>Details</strong> below</td></tr>
<tr><td><a href="02_extensions/04_api.html#trr"><code>TypedRowRender</code> (coming soon)</a></td><td>Parser for more complex stream output</td></tr>
<tr><td></td><td><a href="02_extensions/04_api.html#trrCol"><code>TypedRowRenderAPIColumns</code></a> - show stream line as columns</td></tr>
<tr><td></td><td><a href="02_extensions/04_api.html#trrExt"><code>TypedRowRenderAPIExternal</code></a> - use custom Angular component as stream</td></tr>
</tbody></table>
</div><h3 id="rbp"><a class="header" href="#rbp">RowBoundParser</a></h3>
<pre><code class="language-Javascript">// Typescript

/**
 * Allows creating row parser, which will bound with plugin's host.
 * It means: this row parser will be applied only to data, which was
 * received from plugin's host.
 * It also means: usage of this kind of plugin makes sense only if plugin has
 * host part (backend part), which delivery some data. A good example would be:
 * serial port plugin. Host part extracts data from serial port and sends into
 * stream; render (this kind of plugin) applies only to data, which were gotten
 * from serial port.
 * @usecases decoding stream output content; converting stream output into human-readable format
 * @requirements TypeScript or JavaScript
 * @examples Base64string parser, HEX converting into a string and so on
 * @class RowBoundParser
 */
export declare abstract class RowBoundParser {
    /**
     * This method will be called with each line in stream was gotten from plugin's host
     * @param {string} str - single line from stream (comes only from plugin's host)
     * @param {EThemeType} themeTypeRef - reference to active theme (dark, light and so on)
     * @param {IRowInfo} row - information about current row (see IRowInfo for more details)
     * @returns {string} method should return a string.
     */
    abstract parse(str: string, themeTypeRef: EThemeType, row: IRowInfo): string;
}
</code></pre>
<h3 id="example---rowboundparser"><a class="header" href="#example---rowboundparser">Example - RowBoundParser</a></h3>
<div class="tab rbp">
  <button class="tablinks active" onclick="openCode(event, 'rbp_index.ts')">index.ts</button>
</div>
<div id="rbp_index.ts" class="tabcontent rbp active">
<pre><code class="language-Javascript">
import * as Toolkit from 'chipmunk.client.toolkit';                                                 // Import UI API to extend Parser class
class ParseMe extends Toolkit.RowBoundParser {                                                      // Extend parser class with Abstract parser class 
    public parse(str: string, themeTypeRef: Toolkit.EThemeType, row: Toolkit.IRowInfo): string {    // Create parser which modifies and returns parsed string
        return `--> ${str}`;                                                                        // Return string with --> in front
    }
} 
const gate: Toolkit.PluginServiceGate | undefined = (window as any).logviewer;                      // Identification of the plugin
if (gate === undefined) {                                                                           // If binding didn't work print out error message
    console.error(`Fail to find logviewer gate.`);
} else {
    gate.setPluginExports({                                                                         // Set parser(s) to export here (Setting Multiple parsers possible)
        parser: new ParseMe()                                                                       // Create parser instance (Free to choose parser name)
    });
}
</code></pre>
</div>
<h3 id="rcp"><a class="header" href="#rcp"> RowCommomParser </a></h3>
<pre><code class="language-Javascript">// Typescript

/**
 * Allows creating row parser, which will be applied to each new line in stream.
 * @usecases decoding stream output content; converting stream output into human-readable format
 * @requirements TypeScript or JavaScript
 * @examples Base64string parser, HEX converting into a string and so on
 * @class RowCommonParser
 */
export declare abstract class RowCommonParser {
    /**
     * This method will be called with each line in stream
     * @param {string} str - single line from stream
     * @param {EThemeType} themeTypeRef - reference to active theme (dark, light and so on)
     * @param {IRowInfo} row - information about current row (see IRowInfo for more details)
     * @returns {string} method should return a string.
     */
    abstract parse(str: string, themeTypeRef: EThemeType, row: IRowInfo): string;
}
</code></pre>
<h3 id="example---rowcommonparser"><a class="header" href="#example---rowcommonparser">Example - RowCommonParser</a></h3>
<div class="tab rcp">
  <button class="tablinks active" onclick="openCode(event, 'rcp_index.ts')">index.ts</button>
</div>
<div id="rcp_index.ts" class="tabcontent rcp active">
<pre><code class="language-Javascript">
import * as Toolkit from 'chipmunk.client.toolkit';                                                 // Import UI API to extend Parser class
class ParseMe extends Toolkit.RowCommonParser {                                                     // Extend parser class with Abstract parser class 
    public parse(str: string, themeTypeRef: Toolkit.EThemeType, row: Toolkit.IRowInfo): string {    // Create parser which modifies and returns parsed string
        return `--> ${str}`;                                                                        // Return string with --> in front
    }
} 
const gate: Toolkit.PluginServiceGate | undefined = (window as any).logviewer;                      // Identification of the plugin
if (gate === undefined) {                                                                           // If binding didn't work print out error message
    console.error(`Fail to find logviewer gate.`);
} else {
    gate.setPluginExports({                                                                         // Set parser(s) to export here (Setting Multiple parsers possible)
        parser: new ParseMe()                                                                       // Create parser instance (Free to choose parser name)
    });
}
</code></pre>
</div>
<h3 id="rtp"><a class="header" href="#rtp"> RowTypedParser </a></h3>
<pre><code class="language-Javascript">// Typescript

/**
 * Allows creating row parser with checking the type of source before.
 * It means this parser could be bound with some specific type of source,
 * for example with some specific file's type (DLT, log and so on)
 * @usecases decoding stream output content; converting stream output into human-readable format
 * @requirements TypeScript or JavaScript
 * @examples Base64string parser, HEX converting into a string and so on
 * @class RowTypedParser
 */
export declare abstract class RowTypedParser {
    /**
     * This method will be called with each line in stream
     * @param {string} str - single line from stream
     * @param {EThemeType} themeTypeRef - reference to active theme (dark, light and so on)
     * @param {IRowInfo} row - information about current row (see IRowInfo for more details)
     * @returns {string} method should return a string.
     */
    abstract parse(str: string, themeTypeRef: EThemeType, row: IRowInfo): string;
    /**
     * This method will be called for each line of stream before method "parse" will be called.
     * @param {string} sourceName - name of source
     * @returns {boolean} - true - method "parse" will be called for this line; false - parser will be ignored
     */
    abstract isTypeMatch(sourceName: string): boolean;
}
</code></pre>
<h3 id="example---rowtypedparser"><a class="header" href="#example---rowtypedparser">Example - RowTypedParser</a></h3>
<div class="tab rtp">
  <button class="tablinks active" onclick="openCode(event, 'rtp_index.ts')">index.ts</button>
</div>
<div id="rtp_index.ts" class="tabcontent rtp active">
<pre><code class="language-Javascript">
import * as Toolkit from 'chipmunk.client.toolkit';                                                 // Import UI API to extend Parser class
class ParseMe extends Toolkit.RowTypedParser {                                                      // Extend parser class with Abstract parser class 
    public parse(str: string, themeTypeRef: Toolkit.EThemeType, row: Toolkit.IRowInfo): string {    // Create parser which modifies and returns parsed string
        return `--> ${str}`;                                                                        // Return string with --> in front
    }
    public isTypeMatch(fileName: string): boolean {                                                 // Typecheck for each line of stream before parsing
        if (typeof fileName === 'string' && fileName.search(/\.txt/) > -1) {                        // Check if source is a .txt file
            return true;                                                                            // Return true in case the it is a .txt file
        }
    }
}
const gate: Toolkit.PluginServiceGate | undefined = (window as any).logviewer;                      // Identification of the plugin
if (gate === undefined) {                                                                           // If binding didn't work print out error message
    console.error(`Fail to find logviewer gate.`);
} else {
    gate.setPluginExports({                                                                         // Set parser(s) to export here (Setting Multiple parsers possible)
        parser: new ParseMe()                                                                       // Create parser instance (Free to choose parser name)
    });
}
</code></pre>
</div>
<h3 id="sp"><a class="header" href="#sp"> SelectionParser</a></h3>
<pre><code class="language-Javascript">// Typescript

/**
 * Allows creating parser of selection.
 * Name of the parser will be shown in the context menu of selection. If a user selects parser,
 * parser will be applied to selection and result will be shown on tab "Details"
 * @usecases decoding selected content; converting selected content into human-readable format
 * @requirements TypeScript or JavaScript
 * @examples encrypting of data, Base64string parser, HEX converting into a string and so on
 * @class SelectionParser
 */
export declare abstract class SelectionParser {
    /**
     * This method will be called on user selection
     * @param {string} str - selection in main view or search results view
     * @param {EThemeType} themeTypeRef - reference to active theme (dark, light and so on)
     * @returns {string} method should return a string or HTML string
     */
    abstract parse(str: string, themeTypeRef: EThemeType): string | THTMLString;
    /**
     * Should return name of parser to be shown in context menu of selection
     * @param {string} str - selection in main view or search results view
     * @returns {string} name of parser
     */
    abstract getParserName(str: string): string | undefined;
}
</code></pre>
<h3 id="example---selectionparser"><a class="header" href="#example---selectionparser">Example - SelectionParser</a></h3>
<div class="tab sp">
  <button class="tablinks active" onclick="openCode(event, 'sp_index.ts')">index.ts</button>
</div>
<div id="sp_index.ts" class="tabcontent sp active">
<pre><code class="language-Javascript">
import * as Toolkit from 'chipmunk.client.toolkit';                                                 // Import UI API to extend Parser class
class ParseMe extends Toolkit.SelectionParser {                                                     // Extend parser class with Abstract parser class 
    public parse(str: string, themeTypeRef: Toolkit.EThemeType): string {                           // Create parser which modifies and returns parsed string
        return `--> ${str}`;                                                                        // Return string with --> in front
    }
    public getParserName(str: string) {                                                             // Create a parser that checks if the string only consists of digits
        if ( str.search(/^\d+$/) {                                                                  // If the string only consists of numbers
            return 'Hightlight number';                                                             // return the name of the parser and create an option upon right-clicking
        }
        return undefined;                                                                           // if it's not the case, return 'undefined' to not create an option upon right-clicking
    }
} 
const gate: Toolkit.PluginServiceGate | undefined = (window as any).logviewer;                      // Identification of the plugin
if (gate === undefined) {                                                                           // If binding didn't work print out error message
    console.error(`Fail to find logviewer gate.`);
} else {
    gate.setPluginExports({                                                                         // Set parser(s) to export here (Setting Multiple parsers possible)
        parser: new ParseMe()                                                                       // Create parser instance (Free to choose parser name)
    });
}
</code></pre>
</div>
<h3 id="trr"><a class="header" href="#trr"> TypedRowRender </a></h3>
<pre><code class="language-Javascript">// Typescript

/**
 * This class is used for more complex renders of stream output. Like:
 * - TypedRowRenderAPIColumns - to show stream line as columns
 * - TypedRowRenderAPIExternal - to use custom Angular component as stream
 * line render
 *
 * @usecases to show content in columns; to have full HTML/LESS features for rendering
 * @class TypedRowRender
 */
export declare abstract class TypedRowRender&lt;T&gt; {
    /**
     * This method will be called for each line of a stream before method "parse" will be called.
     * @param {string} sourceName - name of source
     * @returns {boolean} - true - method "parse" will be called for this line; false - parser will be ignored
     */
    abstract isTypeMatch(sourceName: string): boolean;
    /**
     * This method will return one of the supported types of custom renders:
     * - columns
     * - external
     * @returns {ETypedRowRenders} - type of custom render
     */
    abstract getType(): ETypedRowRenders;
    /**
     * Should return an implementation of custom render. An instance of one of the next renders:
     * - TypedRowRenderAPIColumns
     * - TypedRowRenderAPIExternal
     */
    abstract getAPI(): T;
}
</code></pre>
<h3 id="example---typedrowrender"><a class="header" href="#example---typedrowrender">Example - TypedRowRender</a></h3>
<blockquote>
<p><strong>IMPORTANT</strong>: It's important to note, that <code>TypedRowRender</code> <strong>cannot</strong> be used by itself, but instead used to create <code>TypedRowRenderAPIColumns</code> and <code>TypedRowRenderAPIExternal</code> renderers. For examples and further information check out the sections <a href="02_extensions/04_api.html#trrCol">TypedRowRenderAPIColumns</a> and <a href="02_extensions/04_api.html#trrExt">TypedRowRenderAPIExternal</a></p>
</blockquote>
<h2 id="ident"><a class="header" href="#ident"> Identification </a></h2>
<p>The abstract classes listed below are necessary for the <strong>identification and registration</strong> of the plugin.</p>
<h3 id="ngModule"><a class="header" href="#ngModule">PluginNgModule</a></h3>
<pre><code class="language-Javascript">// Typescript

/**
 * Root module class for Angular plugin. Should be used by the developer of a plugin (based on Angular) to
 * let core know, which module is a root module of plugin.
 * One plugin can have only one instance of this module.
 * @usecases views, complex components, addition tabs, Angular components
 * @requirements Angular, TypeScript
 * @class PluginNgModule
 */
export declare class PluginNgModule {
    constructor(name: string, description: string) {}
}
</code></pre>
<h3 id="example---pluginngmodule"><a class="header" href="#example---pluginngmodule">Example - PluginNgModule</a></h3>
<p>This example shows how to create a simple plugin along with the usage of <code>PluginNgModule</code>:</p>
<div class="tab ng">
  <button class="tablinks" onclick="openCode(event, 'ng_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'ng_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'ng_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'ng_module.ts')">module.ts</button>
</div>
<div id="ng_template.html" class="tabcontent ng">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;
</code></pre>
</div>
<div id="ng_styles.less" class="tabcontent ng">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="ng_component.ts" class="tabcontent ng active">
<pre><code class="language-Javascript">
import { Component } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',                                // Choose the selector name of the plugin
    templateUrl: './template.html',                     // Assign HTML file as template
    styleUrls: ['./styles.less']                        // Assign LESS file as style sheet file})
export class ExampleComponent {
    constructor() { }
}
</code></pre>
</div>
<div id="ng_module.ts" class="tabcontent ng">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                       // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';                 // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';             // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                         // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                               // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                               // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {      // <-- The module class of the plugin extends from Toolkit.PluginNgModule
    constructor() {
        super('Example', 'Create an example plugin');           // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<h3 id="pls"><a class="header" href="#pls">PluginService</a></h3>
<pre><code class="language-Javascript">// Typescript

/**
 * Service which can be used to get access to plugin API
 * Plugin API has a collection of methods to listen to major core events and
 * communicate between render and host of plugin.
 * Into plugin's Angular components (like tabs, panels, and dialogs) API object will be
 * delivered via inputs of a component. But to have global access to API developer can
 * create an instance of this class.
 *
 * Note: an instance of this class should be exported with PluginNgModule (for Angular plugins) or
 * with PluginServiceGate.setPluginExports (for none-Angular plugins)
 *
 * @usecases Create global (in the scope of plugin) service with access to plugin's API and core's API
 * @class PluginService
 */
export declare abstract class PluginService {
    private _apiGetter;
    /**
     * @property {Subject&lt;boolean&gt;} onAPIReady subject will be emitted on API is ready to use
     */
    onAPIReady: Subject&lt;boolean&gt;;
    /**
     * Should be used to get access to API of plugin and core.
     * Note: will return undefined before onAPIReady will be emitted
     * @returns {API | undefined} returns an instance of API or undefined if API isn't ready to use
     */
    getAPI(): IAPI | undefined;
}
</code></pre>
<h3 id="example---pluginservice"><a class="header" href="#example---pluginservice">Example - PluginService</a></h3>
<p>This example shows how to create a service class, that extends from <code>PluginService</code>, which allows global access to the <code>API</code> by import the service class:</p>
<div class="tab pls">
  <button class="tablinks" onclick="openCode(event, 'pls_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'pls_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'pls_service.ts')">service.ts</button>
  <button class="tablinks" onclick="openCode(event, 'pls_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'pls_module.ts')">module.ts</button>
</div>
<div id="pls_template.html" class="tabcontent pls">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;
</code></pre>
</div>
<div id="pls_styles.less" class="tabcontent pls">
<pre><code class="language-CSS">p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="pls_service.ts" class="tabcontent pls active">
<pre><code class="language-Javascript">
import * as Toolkit from 'chipmunk.client.toolkit';
export class Service extends Toolkit.PluginService {                    // The service class has to inherit the PluginService from chipmunk.client.toolkit to get access the the API methods
    private api: Toolkit.IAPI | undefined;                              // Instance variable to assign API
    constructor() {
        super();                                                        // Call parent constructor
    }
    private _onReady() {                                                // Method to be called when the API is ready
        this.api = this.getAPI();                                       // Assign the API to instance variable
        if (this.api === undefined) {                                   // Check if the API is defined to prevent errors
            console.log('API not defined!');
            return;
        }
    }
    public printID(): string {
        console.log(`Session id: ${this.api.getActiveSessionId()}`);    // Prints session ID in the console
    }
}
export default (new Service());                                         // Export the instantiated service class
</code></pre>
</div>
<div id="pls_component.ts" class="tabcontent pls">
<pre><code class="language-Javascript">
import { Component } from '@angular/core';
import Service from './service.ts'              // Import the service class to use in main component of plugin
@Component({
    selector: 'example',                        // Choose the selector name of the plugin
    templateUrl: './template.html',             // Assign HTML file as template
    styleUrls: ['./styles.less']                // Assign LESS file as style sheet file})
export class ExampleComponent {
    constructor() { 
            Service.printID();                  // Print session ID in the console
    }
}
</code></pre>
</div>
<div id="pls_module.ts" class="tabcontent pls">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                       // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';                 // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';             // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                         // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                               // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                               // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {      // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');           // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="pls_public_api.ts" class="tabcontent pls">
<pre><code class="language-Javascript">
import Service from './service';
export * from './component';
export * from './module';
export { Service };
</code></pre>
</div>
<blockquote>
<p><strong>IMPORTANT</strong>: It's important to note, that the <code>Service</code> HAS to be exported to be used globally (in scope of the plugin)</p>
</blockquote>
<h3 id="psg"><a class="header" href="#psg"> PluginServiceGate </a></h3>
<pre><code class="language-Javascript">// Typescript

/**
 * Used for none-Angular plugins to delivery plugin's exports into the core of chipmunk
 * Developer can create none-Angular plugin. In global namespace of the main javascript file will be
 * available implementation of PluginServiceGate.
 * For example:
 * =================================================================================================
 * const gate: Toolkit.PluginServiceGate | undefined = (window as any).logviewer;
 * gate.setPluginExports({
 *     parser: new MyParserOfEachRow(),
 * });
 * =================================================================================================
 * This code snippet registered a new parser for output "MyParserOfEachRow"
 * @usecases should be used for none-angular plugins to register parsers
 * @class PluginServiceGate
 */
export declare abstract class PluginServiceGate {
    /**
     * Internal usage
     */
    abstract setPluginExports(exports: IPluginExports): void;
    /**
     * Internal usage
     */
    abstract getCoreModules(): ICoreModules;
    /**
     * Internal usage
     */
    abstract getRequireFunc(): TRequire;
}
</code></pre>
<h3 id="example---pluginservicegate"><a class="header" href="#example---pluginservicegate">Example - PluginServiceGate</a></h3>
<p>This example shows how to create a parser, that puts '--&gt;' in front of every line in the output.</p>
<div class="tab psge">
  <button class="tablinks active" onclick="openCode(event, 'psge_index.ts')">index.ts</button>
</div>
<div id="psge_index.ts" class="tabcontent psge active">
<pre><code class="language-Javascript">
import * as Toolkit from 'chipmunk.client.toolkit';                                                 // Import front-end API to extend Parser class
class ParseMe extends Toolkit.RowCommonParser {                                                    // Extend parser class with Abstract parser class 
    public parse(str: string, themeTypeRef: Toolkit.EThemeType, row: Toolkit.IRowInfo): string {    // Create parser which modifies and returns parsed string
        return `--> ${str}`;                                                                        // Return string with --> in front
    }
} 
const gate: Toolkit.PluginServiceGate | undefined = (window as any).logviewer;                      // <-- Usage of PluginServiceGate, Identification of the plugin
if (gate === undefined) {                                                                           // If binding didn't work print out error message
    console.error(`Fail to find logviewer gate.`);
} else {
    gate.setPluginExports({                                                                         // Set parser(s) to export here (Setting Multiple parsers possible)
        parser: new ParseMe()                                                                       // Create parser instance (Free to choose parser name)
    });
}
</code></pre>
</div>
<!--
<h3 id="trrCol"><a class="header" href="#trrCol"> TypedRowRenderAPIColumns </a></h3>

```Javascript
// Typescript

export interface IColumnWidth {
    width: number;
    min: number;
}

/**
 * Allows presenting a line of a stream as a collection of columns.
 * It should be used with TypedRowRender class (as a generic class), like:
 *
 * class TypedRowRender<TypedRowRenderAPIColumns> { ... }
 *
 * @usecases decode / convert line of stream and show it as columns
 * @requirements TypeScript or JavaScript
 * @class TypedRowRenderAPIColumns
 */
export abstract class TypedRowRenderAPIColumns {
    /**
     * Should returns headers of columns
     * @returns {string[]} headers of columns
     */
    public abstract getHeaders(): string[];

    /**
     * Should return values of columns
     * @param {string} str - single line from stream
     * @returns {string[]} values of columns
     */
    public abstract getColumns(str: string): string[];

    /**
     * Should return default widths of columns
     * @returns {IColumnWidth[]} widths of columns
     */
    public abstract getDefaultWidths(): IColumnWidth[];

}
```

<h3 id="example---typedrowrenderapicolumns"><a class="header" href="#example---typedrowrenderapicolumns">Example - TypedRowRenderAPIColumns</a></h3>

<div class="tab trrc">
  <button class="tablinks" onclick="openCode(event, 'trrc_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'trrc_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'trrc_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'trrc_row_columns_api.ts')">row.columns_api.ts</button>
  <button class="tablinks" onclick="openCode(event, 'trrc_row_columns.ts')">row.columns.ts</button>
  <button class="tablinks" onclick="openCode(event, 'trrc_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'trrc_public_api.ts')">public_api.ts</button>
</div>

<div id="trrc_public_api.ts" class="tabcontent trrc">
<pre><code class="language-Javascript">
import { ExampleRowRender } from './lib/row/render';    // Import the renderer
const externalRowRender = new ExampleRowRender();       // Instanticate the renderer once
export { externalRowRender };                           // Export the instantiated renderer
export * from './lib/component';
export * from './module';
</code></pre>
</div>

<div id="trrc_module.ts" class="tabcontent trrc">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';
import { ExampleComponent } from './lib/component';
import { ExampleRowComponent } from './lib/row/component';
import * as Toolkit from 'chipmunk.client.toolkit';
@NgModule({
    entryComponents: [ ExampleComponent ],
    declarations: [ ExampleComponent ],
    imports: [ ],
    exports: [ ExampleComponent ]
})
export class PluginModule extends Toolkit.PluginNgModule {
    constructor() {
        super('Example', 'Provides access to example plugin');
    }
}
</code></pre>
</div>

<div id="trrc_component.ts" class="tabcontent trrc active">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: Toolkit.EViewsTypes.sidebarVertical,
    templateUrl: './template.html',
    styleUrls: ['./styles.less']
})
export class SidebarVerticalComponent {
    @Input() public api: Toolkit.IAPI;                  // Assign API to instance variable
    @Input() public session: string;                    // Assign session ID to instance variable
    constructor() {
        this.api.getIPC().send({                        // Send session ID to process part of plugin
            stream: this.session,
            command: 'session'
        }).catch((error: Error) => {
            console.log('Error occured');
        });
    }
}
</code></pre>
</div>

<div id="trrc_styles.less" class="tabcontent trrc">
<pre><code class="language-CSS">
p{
    color: #ffffff
}
</code></pre>
</div>

<div id="trrc_template.html" class="tabcontent trrc">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;
</code></pre>
</div>

<div id="trrc_row_columns_api.ts" class="tabcontent trrc">
<pre><code class="language-Javascript">
import * as Toolkit from 'chipmunk.client.toolkit';
export const CDelimiters = {
    columns: '\u0004',
    arguments: '\u0005',
};
export const CColumnsHeaders = [                                                        // Colmun headers for table like view
    'WORD 0',
    'WORD 1',
    'WORD 2',
];
export class ExampleRowColumnsAPI extends Toolkit.TypedRowRenderAPIColumns {
    constructor() {
        super();
    }
    public getHeaders(): string[] {                                                     // Getter method for headers
        return CColumnsHeaders;
    }
    public getColumns(str: string): string[] {                                          // Split stream to words by TAB
        return str.split('\t');
    }
    public getDefaultWidths(): Array<{ width: number, min: number }> {                  // Define width of columns
        return [
            { width: 50, min: 30 },
            { width: 50, min: 30 },
            { width: 50, min: 30 },
        ];
    }
}
</code></pre>
</div>

<div id="trrc_row_columns.ts" class="tabcontent trrc">
<pre><code class="language-Javascript">
import * as Toolkit from 'chipmunk.client.toolkit';
import { ExampleRowColumnsAPI } from './row.columns.api';
export class ExampleRowColumns extends Toolkit.TypedRowRender<ExampleRowColumnsAPI> {   // Create new column renderer of API type defined in ExampleColumnsAPI
    private _api: ExampleRowColumnsAPI = new ExampleRowColumnsAPI();
    constructor() {
        super();
    }
    public getType(): Toolkit.ETypedRowRenders {                                        // Getter method for renderer type
        return Toolkit.ETypedRowRenders.columns;
    }
    public isTypeMatch(fileName: string): boolean {                                     // Method to check if opened file is a .txt file
        if (fileName.search(/\.txt/) > -1) {
            return true;
        }
    }
    public getAPI(): ExampleRowColumnsAPI {                                             // Getter method for API
        return this._api;
    }
}
</code></pre>
</div>

> **NOTE**: To test this plugin, create a `.txt` file with some text in it and the words being seperated by `\t`.

<h3 id="trrExt"><a class="header" href="#trrExt"> TypedRowRenderAPIExternal </a></h3>

```Javascript
// Typescript

const CSignature = 'TypedRowRenderAPIExternal';

/**
 * Allows injecting Angular component into view as each row render
 * It should be used with TypedRowRender class (as a generic class), like:
 *
 * class TypedRowRender<TypedRowRenderAPIExternal> { ... }
 *
 * @usecases decode / convert line of stream and show with specific render
 * @requirements Angualr, TypeScript
 * @class TypedRowRenderAPIExternal
 */
export abstract class TypedRowRenderAPIExternal {
    /**
     * This method should return angular's component selector.
     * Note: plugin should already have an implementation of the component,
     * which will be used as render. Selector of such component should
     * be returned here.
     * @returns {string} angular's component selector
     */
    public abstract getSelector(): string;

    /**
     * Method returns inputs for render component
     * @returns { { [key: string]: any } } inputs for render-components
     */
    public abstract getInputs(): { [key: string]: any };
}
```

<h3 id="example---typedrowrenderapiexternal"><a class="header" href="#example---typedrowrenderapiexternal">Example - TypedRowRenderAPIExternal</a></h3>

**User-Interface UI**

> **IMPORTANT: This implementation will be available soon**

<div class="tab trre">
  <button class="tablinks" onclick="openCode(event, 'trreR_template.html')">/row/template.html</button>
  <button class="tablinks" onclick="openCode(event, 'trreR_styles.less')">/row/styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'trreR_component.ts')">/row/component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'trre_render_api.ts')">/row/render_api.ts</button>
  <button class="tablinks" onclick="openCode(event, 'trre_render.ts')">/row/render.ts</button>
  <button class="tablinks" onclick="openCode(event, 'trre_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'trre_styles.less')">styles.less</button>
  <button class="tablinks" onclick="openCode(event, 'trre_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'trre_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'trre_public_api.ts')">public_api.ts</button>
</div>

<div id="trre_render_api.ts" class="tabcontent trre">
<pre><code class="language-Javascript">
import * from 'chipmunk.client.toolkit';
export class ExampleRowRenderAPI extends Toolkit.TypedRowRenderAPIExternal {
    private _selector: string = 'lib-example-row-component';                    // Create component selector name
    constructor() {
        super();
    }
    public getSelector(): string {                                              // Getter method for the Angular component selector (HTML tag name)
        return this._selector;
    }
    public getInputs(): { [key: string]: any } {                                // Getter method for inputs for renderer component
        return { service: null };
    }
}
</code></pre>
</div>

<div id="trre_render.ts" class="tabcontent trre">
<pre><code class="language-Javascript">
import * as Toolkit from 'chipmunk.client.toolkit';
import { ExampleRowRenderAPI } from './render.api';
export class ExampleRowRender extends Toolkit.TypedRowRender<ExampleRowRenderAPI> {     // Extend renderer from TypedRowRenderer with the ExampleRowRendererAPI type (declared above)
    private _api: ExampleRowRenderAPI = new ExampleRowRenderAPI();                      // Instantiate renderer API to assign API to instance variable
    constructor() {
        super();
    }
    public getType(): Toolkit.ETypedRowRenders {                                        // Getter method for the type of the renderer
        return Toolkit.ETypedRowRenders.external;
    }
    public isTypeMatch(sourceName: string): boolean {                                   // Check if the source of the message is from the plugin
        return sourceName === 'example';
    }
    public getAPI(): ExampleRowRenderAPI {                                              // Getter method for API
        return this._api;
    }
}
</code></pre>
</div>

<div id="trreR_component.ts" class="tabcontent trre active">
<pre><code class="language-Javascript">
import { Component, OnDestroy, ChangeDetectorRef, AfterViewInit, AfterContentInit, Input } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import * as Toolkit from 'chipmunk.client.toolkit';
import { Subscription, Subject } from 'rxjs';
@Component({
    selector: 'lib-example-row-component',
    templateUrl: './template.html',
    styleUrls: ['./styles.less']
})
export class ExampleRowComponent implements AfterViewInit, OnDestroy, AfterContentInit {
    @Input() public api: Toolkit.IAPI;                                                                          // Assign API to instance variable
    @Input() public session: string;                                                                            // Assign session ID to instance variable
    @Input() public html: string;                                                                               // Assign message from stream to instance variable
    @Input() public update: Subject<{ [key: string]: any }>;                                                    // Assign subscription object for changes to instance variable
    public _ng_html: SafeHtml;                                                                                  // Instance variable to save message of the stream
    private _subscriptions: { [key: string]: Subscription } = {};
    private _destroyed: boolean = false;
    constructor(private _cdRef: ChangeDetectorRef, private _sanitizer: DomSanitizer) { }
    public ngOnDestroy() {
        this._destroyed = true;
        Object.keys(this._subscriptions).forEach((key: string) => {                                             // Unsubscribe from all sources when the object is destroyed
            this._subscriptions[key].unsubscribe();
        });
    }
    public ngAfterViewInit() {
        if (typeof this.html !== 'string') {                                                                    // Check for correct format of stream message to prevent errors
            return;
        }
        this._getHTML();
    }
    public ngAfterContentInit() {
        if (this.update === undefined) {                                                                        // Error prevention by checking if the object to subscribe exists
            return;
        }
        this._subscriptions.update = this.update.asObservable().subscribe(this._onInputsUpdated.bind(this));    // Subscribe to the changes occuring on the input/stream
    }
    private _onInputsUpdated(inputs: any) {                                                                     // Method to be called upon changes on the input/stream
        if (inputs === undefined || inputs === null) {
            return;
        }
        if (typeof inputs.html === 'string' && inputs.html !== this.html) {                                     // Check for the right format of the message
            this.html = inputs.html;                                                                            // Assign message from stream to string for HTML element
            this._getHTML();                                                                                    // Security procedure
        }
    }
    private _getHTML() {
        this._ng_html = this._sanitizer.bypassSecurityTrustHtml(this.html);                                     // Processes received message to increase security
        this._forceUpdate();                                                                                    // Update HTML elements
    }
    private _forceUpdate() {                                                                                    // Method to update HTML elements
        if (this._destroyed) {
            return;
        }
        this._cdRef.detectChanges();
    }
}
</code></pre>
</div>

<div id="trreR_styles.less" class="tabcontent trre">
<pre><code class="language-CSS">
span.dot{
    height: 15px;
    width: 15px;
    background-color: #FF0000;
    border-radius: 50%;
    display: inline-block;
}
span.content{
    color: #FFFFFF;
}
</code></pre>
</div>

<div id="trreR_template.html" class="tabcontent trre">
<pre><code class="language-HTML">
&lt;span class="dot"&gt;&lt;/span&gt;                               &lt;!-- Rendered line puts a dot (modified in LESS file) --&gt;
&lt;span class="content" [innerHTML]="_ng_html"&gt;&lt;/span&gt;    &lt;!-- Next to the dot comes the actual message --&gt;
</code></pre>
</div>

<div id="trre_public_api.ts" class="tabcontent trre">
<pre><code class="language-Javascript">
import { ExampleRowRender } from './lib/row/render';    // Import renderer to instantiate
const externalRowRender = new ExampleRowRender();       // Instantiate renderer
export { externalRowRender };                           // Export it to make it available in the application
export * from './lib/component';
export * from './module';
</code></pre>
</div>

<div id="trre_module.ts" class="tabcontent trre">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';
import { ExampleComponent } from './lib/component';
import { ExampleRowComponent } from './lib/row/component';
import * as Toolkit from 'chipmunk.client.toolkit';
@NgModule({
    entryComponents: [ ExampleComponent, SerialRowComponent ],
    declarations: [ ExampleComponent, SerialRowComponent ],
    imports: [ ],
    exports: [ ExampleComponent, SerialRowComponent ]
})
export class PluginModule extends Toolkit.PluginNgModule {
    constructor() {
        super('Example', 'Provides access to example plugin');
    }
}
</code></pre>
</div>

<div id="trre_component.ts" class="tabcontent trre">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: Toolkit.EViewsTypes.sidebarVertical,
    templateUrl: './template.html',
    styleUrls: ['./styles.less']
})
export class SidebarVerticalComponent {
    @Input() public api: Toolkit.IAPI;                  // Assign API to instance variable
    @Input() public session: string;                    // Assign session ID to instance variable
    constructor() {
        this.api.getIPC().send({                        // Send session ID to the process part
            stream: this.session,
            command: 'session'
        }).catch((error: Error) => {
            console.log('Error occured');
        });
    }
}
</code></pre>
</div>

<div id="trre_styles.less" class="tabcontent trre">
<pre><code class="language-CSS">
p {
    color: #ffffff
}
</code></pre>
</div>

<div id="trre_template.html" class="tabcontent trre">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;
</code></pre>
</div>

**process part**

<div class="tab trreB">
  <button class="tablinks active" onclick="openCode(event, 'trre_main.ts')">main.ts</button>
</div>

<div id="trre_main.ts" class="tabcontent trreB active">
<pre><code class="language-Javascript">
import PluginIPCService, { IPCMessages } from 'chipmunk.plugin.ipc';
class ExampleBackend {
    public static count = 0;                                                                                    // Create counting variable
    constructor(){
        this._onIncomeRenderIPCMessage = this._onIncomeRenderIPCMessage.bind(this);                             // Bind method for subscription
        PluginIPCService.subscribe(IPCMessages.PluginInternalMessage, this._onIncomeRenderIPCMessage);          // Subscribe to messages from the UI
    }
    private _onIncomeRenderIPCMessage(message: IPCMessages.PluginInternalMessage) {                             // Create method to listen to messages from the UI
        if (message.data.command === 'session') {                                                               // Check if the session ID have been sent
            this.send(message.stream);
        } else {
            console.warn(`Unknown command: ${message.data.command}`);
        }
    }
    private send(stream: string) {                                                                              // When the session ID has been sent
        if(ExampleBackend.count <= 10) {                                                                        // Send every 500ms 10 times "Hello World! No.: <Counted times>" to the UI
            return setTimeout(() => {
                ExampleBackend.count++;
                PluginIPCService.sendToStream(new Buffer(`Hello World! No.: ${ExampleBackend.count}`, 'utf-8'), stream);
                this.send(stream);
            }, 500);
        }
    }
}
export default new ExampleBackend();
</code></pre>
</div>
-->
<!--
<h2 id="ipc"><a class="header" href="#ipc">3.2 IPC </a></h2>

These abstract classes allow to create different methods to establish communication between the **process part** and the **UI**.

> **IMPORTANT**: `IPC` is only used in the **process part**

```Javascript
// Typescript

/**
 * @class IPC
 * Abstract class, which used for creating a plugin IPC controller.
 * Plugin IPC controller allows communicating between render part of a plugin
 * and backend part of a plugin.
 * Render part (render) - a plugin's part, which executes on UI in browser
 * Backend part (host) - a plugin's part, which executes on process part on nodejs level
 */

export declare abstract class IPC {
    readonly token: string;
    readonly name: string;
    private _logger;
    private _handlers;
    constructor(name: string, token: string) {}
    /**
     * Sends message from render to host.
     * Note: this method doesn't wait for host's response. It's just a sender. This method could be used for example
     * for emitting of events or something like it.
     * @param {any} message - any message to be sent on host
     * @param streamId - id of related stream
     * @returns {Promise<void>} resolved on message successfully sent; reject on sending errors
     */
    abstract send(message: any, streamId?: string): Promise<void>;
    /**
     * Sends a request from render to host.
     * This method sends request-message to host and waits for a response.
     * @param {any} message - any message to be sent on host. As usual, it's an object
     * @param {string} streamId - id of related stream
     * @returns {Promise<void>} resolved with host's response; reject on sending errors
     */
    abstract request(message: any, streamId?: string): Promise<any>;
    /**
     * Subscriber to host messages
     * @param {(message: any) => void} handler - will be called with each host message
     * @returns {Subscription} subscription object, which could be used to unsubscribe
     */
    subscribe(handler: Tools.THandler): Tools.Subscription;
}
```

<h3 id="example---ipc"><a class="header" href="#example---ipc">Example - IPC</a></h3>

This example shows a **Complex plugin** with two buttons demonstrating how to communicate **UI** <-> **process part**.

> **NOTE**: To make use of `IPC` add `IAPI` in the code, since `IAPI` holds the method `getIPC()` which provides an instance of `IPC` with the methods already implemented. (For more information: <a href="02_extensions/04_api.html#iapi">IAPI</a>)

<h2 id="ui"><a class="header" href="#ui">UI</a></h2>

<div class="tab ipc">
  <button class="tablinks" onclick="openCode(event, 'ipc_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'ipc_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'ipc_service.ts')">service.ts</button>
  <button class="tablinks" onclick="openCode(event, 'ipc_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'ipc_public_api.ts')">public_api.ts</button>
</div>

<div id="ipc_template.html" class="tabcontent ipc">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;
&lt;button (click)=&quot;_ng_onRequest()">'request' to backend&lt;/button&gt    &lt;!-- Create button for request-type of message --&gt;
&lt;button (click)=&quot;_ng_onSend()">'send' to backend&lt;/button&gt          &lt;!-- Create button for send-type of message --&gt;
</code></pre>
</div>

<div id="ipc_styles.less" class="tabcontent ipc">
<pre><code class="language-CSS">
p {
    color: white;
}
button {
    position: relative;
    width: 47%;
    height: 3%;
    margin-left: 2%;
    margin-top: 5%;
    color: black;
}
</code></pre>
</div>

<div id="ipc_service.ts" class="tabcontent ipc active">
<pre><code class="language-Javascript">
import * as Toolkit from 'chipmunk.client.toolkit';
export class Service extends Toolkit.PluginService {                                                                                // The service class has to inherit the PluginService from chipmunk.client.toolkit to get access the the API methods
    private api: Toolkit.IAPI | undefined;                                                                                          // Instance variable to assign API
    constructor() {
        super();                                                                                                                    // Call parent constructor
        this._subs.onReady = this.onAPIReady.subscribe(this._onAPIReady.bind(this));                                                // Subscribe to the onAPIReady method from the API to see when the API is ready
    }
    private _onAPIReady() {                                                                                                         // Method to be called when the API is ready
        this.api = this.getAPI();                                                                                                   // Assign the API to instance variable
        if (this.api === undefined) {                                                                                               // Check if the API is defined to prevent errors
            console.log('API not defined!');
            return;
        }
        this._subscriptions.onTabOpen = this.api.getSessionsEventsHub().subscribe().onTabOpen(this._onTabOpen.bind(this));          // Subscribe to the API to call method upon opening a new session/tab
        this._subscriptions.onTabClose = this.api.getSessionsEventsHub().subscribe().onTabClose(this._onTabClose.bind(this));       // Subscribe to the API to call method upon closing a session/tab
        this._subscriptions.onTabChange = this.api.getSessionsEventsHub().subscribe().onTabChange(this._onTabChange.bind(this));    // Subscribe to the API to call method upon changing to another session/tab
    }
    private _onSessionOpen() {                                                                                                      // Method to call upon opening a new session/tab
        this.session = this.api.getActiveSessionId();                                                                               // Get active session ID
        if (this.sessions.includes(this.session)) {                                                                                 // Check if session already exists to prevent double entries
            return;
        }
        if (this.sessions.length === 0) {
            this.incomeMessage();                                                                                                   // Subscribe only if the first session was created
        }
        this.sessions.push(this.session);                                                                                           // Add the session to the list of sessions
    }
    private _onSessionClose(guid: string) {                                                                                         // Method to call upon closing a session/tab
        this.sessions = this.sessions.filter(session => session !== guid);                                                          // Remove closed session from list of sessions
    }
    private _onSessionChange(guid: string) {                                                                                        // Method to call upon changing to another session/tab
        this.session = guid;
    }
    public incomeMessage() {
        this._subscriptions.incomeIPCHostMessage = this.api.getIPC().subscribe((message: any) => {
            if (typeof message !== 'object' && message === null) {
                return;
            }
            if (message.event === 'send') {                                                                                         // Check if it's the expected message
                console.log(`Received onSend: ${message.data.msg}`);                                                                // Print out the message in the console
            }
        });
    }
    public _ng_onRequest() {                                                                                                        // on click function for request-type of message to the process part
        if (this.api) {                                                                                                             // check if API exists
            this.api.getIPC().request({                                                                                             // send request-type of message to the process part
                stream: this.session,
                command: 'request'
            }, this.session).then((response) => {                                                                                   // Catch response from process part
                console.log(`Received onRequest: ${response.msg}`);                                                                 // Print out responsed answer in the console
            }).catch((error: Error) => {
                console.error(error);
            });
      } else {
        console.error('No API found!');
      }
    }
    public _ng_onSend() {                                                                                                           // on click function for send-type of message to the process part
        if (this.api) {                                                                                                             // check if API exists
            this.api.getIPC().send({                                                                                                // send send-type of message to the process part
                stream: this.session,
                command: 'send'
            }, this.session).catch((error: Error) => {
                console.error(error);
            });
        } else {
            console.error('No API found!');
        }
    }
}
export default (new Service());                                                                                                     // Export the instantiated service class
</code></pre>
</div>

<div id="ipc_module.ts" class="tabcontent ipc">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                   // Import the Angular component that is necessary for the setup below
import { Example } from './component';                      // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';         // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ Example ],                              // Declare which components, directives and pipes belong to the module
    imports: [ ],                                           // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ Example ]                                    // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {  // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');       // Call the constructor of the parent class
    }
}
</code></pre>
</div>

<div id="ipc_public_api.ts" class="tabcontent ipc">
<pre><code class="language-Javascript">
import Service from './service';
export * from './component';
export * from './module';
export { Service };
</code></pre>
</div>

> **IMPORTANT**: It's important to note, that the `Service` HAS to be exported to be used globally (in scope of the plugin)

> **NOTE**: Using a service file is one of two ways to make use of the `API` (check out _How to use the API_ in <a href="02_extensions/04_api.html#api">API</a> for more information)

<h2 id="process-part"><a class="header" href="#process-part">process part</a></h2>

<div class="tab ipcB">
  <button class="tablinks active" onclick="openCode(event, 'ipc_main.ts')">main.ts</button>
</div>

<div id="ipc_main.ts" class="tabcontent ipcB active">
<pre><code class="language-Javascript">
import PluginIPCService from 'chipmunk.plugin.ipc';
import { IPCMessages } from 'chipmunk.plugin.ipc';
class Plugin {
    constructor() {
        this._onIncome = this._onIncome.bind(this);
        PluginIPCService.subscribe(IPCMessages.PluginInternalMessage, this._onIncome);                              // <-- Usage of PluginIPCService - Subscribe to incoming messages from UI
    }
    private _onIncome(message: IPCMessages.PluginInternalMessage, response: (res: IPCMessages.TMessage) => any) {   // Message handler for messages from the UI
        switch (message.data.command) {                                                                             // Check incoming command in message from UI
            case 'request':
                return response(new IPCMessages.PluginInternalMessage({                                             // Send response to the UI
                    data: {
                        msg: '\'request\' was successful!'                                                          // Attach string to response
                    },
                    token: message.token,
                    stream: message.stream
                }));
            case 'send':
                return PluginIPCService.sendToPluginHost(message.stream, {                                          // <-- Usage of PluginIPCService - Send message to UI
                    data: {
                        msg: '\'send\' was successful!'                                                             // Attach string to message
                    },
                    event: 'send',
                    streamId: message.stream
                })
            default:
                console.warn(`Unknown command: ${message.data.command}`);
        }
    }
}
const app: Plugin = new Plugin();
</code></pre>
</div>
-->
<h1 id="api_class"><a class="header" href="#api_class">4. Classes </a></h1>
<h2 id="cse"><a class="header" href="#cse">4.1 ControllerSessionsEvents </a></h2>
<pre><code class="language-Javascript">// Typescript

/**
 * This class provides access to sessions events (like close, open, change of session).
 *
 * @usecases to track sessions state
 * @class ControllerSessionsEvents
 */
export class ControllerSessionsEvents {

    public static Events = {
        /**
         * Fired on user switch a tab (session)
         * @name onSessionChange
         * @event {string} sessionId - active session ID
         */
        onSessionChange: 'onSessionChange',
        /**
         * Fired on user open a new tab (session)
         * @name onSessionOpen
         * @event {string} sessionId - a new session ID
         */
        onSessionOpen: 'onSessionOpen',
        /**
         * Fired on user close a new tab (session)
         * @name onSessionClose
         * @event {string} sessionId - ID of closed session
         */
        onSessionClose: 'onSessionClose',
        /**
         * Fired on stream has been changed
         * @name onStreamUpdated
         * @event {IEventStreamUpdate} event - current state of stream
         */
        onStreamUpdated: 'onStreamUpdated',
        /**
         * Fired on search results has been changed
         * @name onSearchUpdated
         * @event {IEventSearchUpdate} event - current state of stream
         */
        onSearchUpdated: 'onSearchUpdated',
    };

    private _emitter: Emitter = new Emitter();

    public destroy() {
        this._emitter.unsubscribeAll();
    }

    public unsubscribe(event: any) {
        this._emitter.unsubscribeAll(event);
    }

    /**
     * Emits event
     * @returns {Event Emitter} - function event emitter
     */
    public emit(): {
        onSessionChange: (sessionId: string) =&gt; void,
        onSessionOpen: (sessionId: string) =&gt; void,
        onSessionClose: (sessionId: string) =&gt; void,
        onStreamUpdated: (event: IEventStreamUpdate) =&gt; void,
        onSearchUpdated: (event: IEventSearchUpdate) =&gt; void,
    } {
        return {
            onSessionChange: this._getEmit.bind(this, ControllerSessionsEvents.Events.onSessionChange),
            onSessionOpen: this._getEmit.bind(this, ControllerSessionsEvents.Events.onSessionOpen),
            onSessionClose: this._getEmit.bind(this, ControllerSessionsEvents.Events.onSessionClose),
            onStreamUpdated: this._getEmit.bind(this, ControllerSessionsEvents.Events.onStreamUpdated),
            onSearchUpdated: this._getEmit.bind(this, ControllerSessionsEvents.Events.onSearchUpdated),
        };
    }

    /**
     * Subscribes to event
     * @returns {Event Subscriber} - function-subscriber for each available event
     */
    public subscribe(): {
        onSessionChange: (handler: TSubscriptionHandler&lt;string&gt;) =&gt; Subscription,
        onSessionOpen: (handler: TSubscriptionHandler&lt;string&gt;) =&gt; Subscription,
        onSessionClose: (handler: TSubscriptionHandler&lt;string&gt;) =&gt; Subscription,
        onStreamUpdated: (handler: TSubscriptionHandler&lt;IEventStreamUpdate&gt;) =&gt; Subscription,
        onSearchUpdated: (handler: TSubscriptionHandler&lt;IEventSearchUpdate&gt;) =&gt; Subscription,
    } {
        return {
            onSessionChange: (handler: TSubscriptionHandler&lt;string&gt;) =&gt; {
                return this._getSubscription&lt;string&gt;(ControllerSessionsEvents.Events.onSessionChange, handler);
            },
            onSessionOpen: (handler: TSubscriptionHandler&lt;string&gt;) =&gt; {
                return this._getSubscription&lt;string&gt;(ControllerSessionsEvents.Events.onSessionOpen, handler);
            },
            onSessionClose: (handler: TSubscriptionHandler&lt;string&gt;) =&gt; {
                return this._getSubscription&lt;string&gt;(ControllerSessionsEvents.Events.onSessionClose, handler);
            },
            onStreamUpdated: (handler: TSubscriptionHandler&lt;IEventStreamUpdate&gt;) =&gt; {
                return this._getSubscription&lt;IEventStreamUpdate&gt;(ControllerSessionsEvents.Events.onStreamUpdated, handler);
            },
            onSearchUpdated: (handler: TSubscriptionHandler&lt;IEventSearchUpdate&gt;) =&gt; {
                return this._getSubscription&lt;IEventSearchUpdate&gt;(ControllerSessionsEvents.Events.onSearchUpdated, handler);
            },
        };
    }
</code></pre>
<h3 id="example---controllersessionevents"><a class="header" href="#example---controllersessionevents">Example - ControllerSessionEvents</a></h3>
<p>This example shows how to call specific methods when a session is created/closed/changed:</p>
<div class="tab cse">
  <button class="tablinks" onclick="openCode(event, 'cse_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'cse_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'cse_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'cse_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'cse_public_api.ts')">public_api.ts</button>
</div>
<div id="cse_template.html" class="tabcontent cse">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;      &lt;!-- Create a line of text --&gt;
</code></pre>
</div>
<div id="cse_styles.less" class="tabcontent cse">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="cse_component.ts" class="tabcontent cse active">
<pre><code class="language-Javascript">
import { Component, Input } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',                                                                                                // Choose the selector name of the plugin
    templateUrl: './template.html',                                                                                     // Assign HTML file as template
    styleUrls: ['./styles.less']                                                                                        // Assign LESS file as style sheet file})
export class ExampleComponent {
    @Input() public api: Toolkit.IAPI;                                                                                  // API assignment
    @Input() public session: string;                                                                                    // Session ID assignment
    @Input() public sessions: Toolkit.ControllerSessionsEvents;                                                         // Session event listener assignment
    private _subs: { [key: string]: Toolkit.Subscription } = {};                                                        // Hashlist for session events
    constructor() {
        this._subs.onSessionChange = this.sessions.subscribe().onSessionChange(this._onSessionSessionChange.bind(this));    // Subscribe to session change event
        this._subs.onSessionOpen = this.sessions.subscribe().onSessionOpen(this._onSessionOpen.bind(this));                 // Subscribe to new session open event
        this._subs.onSessionClose = this.sessions.subscribe().onSessionClose(this._onSessionClose.bind(this));              // Subscribe to session close event
    }
    private _onSessionChange(session: string) {                                                                         // Method when session changes
        this.session = session;                                                                                         // Reassign the session to the session, to which has been changed to
    }
    private _onSessionOpen(session: string) { }                                                                         // Method when new session opens
    private _onSessionClose(session: string) { }                                                                        // Method when session closes
}
</code></pre>
</div>
<div id="cse_module.ts" class="tabcontent cse">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                   // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';             // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';         // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                     // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                           // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                           // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {  // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');       // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="cse_public_api.ts" class="tabcontent cse">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>
<!--
<h2 id="ipc_service"><a class="header" href="#ipc_service">4.2 PluginIPCService </a></h2>

```Javascript
// Typescript

/**
 * @class PluginIPCService
 * @description Service provides communition between plugin's process and parent (main) process
export declare class PluginIPCService extends EventEmitter {
    private _pending;
    private _subscriptions;
    private _handlers;
    private _token;
    private _id;
    private _tokenSubscription;
    private _sockets;
    static Events: {
        close: string;
        closeStream: string;
        openStream: string;
    };
    Events: {
        close: string;
        closeStream: string;
        openStream: string;
    };
    constructor() {}
    sendToPluginHost(session: string, message: any): Promise<any>;
    requestToPluginHost(session: string, message: any): Promise<any>;
    /**
     * Sends message to parent (main) process via IPC without expecting any answer
     * @param {IPCMessages.TMessage} data package of data
     * @returns { Promise<void> }
     */
    send(message: IPCMessages.TMessage): Promise<IPCMessages.TMessage | undefined>;
    response(sequence: string, message: IPCMessages.TMessage): Promise<IPCMessages.TMessage | undefined>;
    /**
     * Sends message to parent (main) process via IPC and waiting for a answer
     * @param {IPCMessages.TMessage} data package of data
     * @returns { Promise<IPCMessages.TMessage | undefined> }
     */
    request(message: IPCMessages.TMessage): Promise<IPCMessages.TMessage | undefined>;
    subscribe(message: Function, handler: THandler): Promise<Subscription>;
    /**
     * Sends chunk of data to data's stream
     * @param {any} chunk package of data
     * @param {string} streamId id of target stream
     * @returns { Promise<void> }
     */
    sendToStream(chunk: Buffer, streamId: string): Promise<void>;
    /**
     * Pipe readable stream with session stream.
     * @returns { Error | undefined } returns errors if stream isn't found
     */
    pipeWithStream(readStream: Stream.Readable, info: IPipedStreamInfo, streamId: string): Promise<void>;
    /**
     * Returns write stream. Can be used to pipe write stream with source of data
     * @returns { Net.Socket }
     */
    private _getStreamSocket;
    /**
     * Sends message to parent (main) process via IPC
     * @param {IPCMessage} data package of data
     * @param {boolean} expectResponse  true - promise will be resolved with income message with same "sequence";
     *                                  false (default) - promise will be resolved afte message be sent
     * @returns { Promise<IPCMessage | undefined> }
     */
    private _send;
    /**
     * Handler of incoming message from parent (main) process
     * @returns void
     */
    private _onMessage;
    private _acceptSocket;
    private _removeSocket;
    private _getRefToMessageClass;
    private _isValidMessageClassRef;
    private _unsubscribe;
    private _onPluginToken;
}
```

<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>

This example shows a **Complex plugin** with two buttons demonstrating how to communicate **UI** <-> **process part**.

<h2 id="ui-1"><a class="header" href="#ui-1">UI</a></h2>

<div class="tab pipc">
  <button class="tablinks" onclick="openCode(event, 'pIPC_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'pIPC_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'pIPC_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'pIPC_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'pIPC_public_api.ts')">public_api.ts</button>
</div>

<div id="pIPC_component.ts" class="tabcontent pipc active">
<pre><code class="language-Javascript">
import { Component, Input, AfterViewInit, OnDestroy } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',
    templateUrl: './template.html',
    styleUrls: ['./styles.less']
})
export class ExampleComponent implements AfterViewInit, OnDestroy {
    @Input() public api: Toolkit.IAPI;                                                              // API assignment
    @Input() public session: string;                                                                // Session ID assignment
    private _subscriptions: { [key: string]: Toolkit.Subscription } = {};                           // Hashlist for session events
    constructor() { }
    ngOnDestroy() {
        Object.keys(this._subscriptions).forEach((key: string) => {                                 // Unsubscribe from all sources when the component is destroyed
            this._subscriptions[key].unsubscribe();
        });
    }
    ngAfterViewInit() {
        this._subscriptions.incomeIPCHostMessage = this.api.getIPC().subscribe((message: any) => {  // Subscribe to process part to listen for messages
            if (typeof message !== 'object' && message === null) {                                  // Check for correct format of message
                return;
            }
            if (message.event === 'send') {                                                         // Check if it's the expected message
                console.log(`Received onSend: ${message.data.msg}`);                                // Print out the message in the console
            }
        });
    }
    public _ng_onRequest() {                                                                        // on click function for request-type of message to the process part
        if (this.api) {                                                                             // check if API exists
            this.api.getIPC().request({                                                             // send request-type of message to the process part
                stream: this.session,
                command: 'request'
            }, this.session).then((response) => {                                                   // Catch response from process part
                console.log(`Received onRequest: ${response.msg}`);                                 // Print out responsed answer in the console
            }).catch((error: Error) => {
                console.error(error);
            });
      } else {
        console.error('No API found!');
      }
    }
    public _ng_onSend() {                                                                           // on click function for send-type of message to the process part
        if (this.api) {                                                                             // check if API exists
            this.api.getIPC().send({                                                                // send send-type of message to the process part
                stream: this.session,
                command: 'send'
            }, this.session).catch((error: Error) => {
                console.error(error);
            });
        } else {
            console.error('No API found!');
        }
    }
}
</code></pre>
</div>

<div id="pIPC_module.ts" class="tabcontent pipc">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';
import { ExampleComponent } from './component';
import * as Toolkit from 'chipmunk.client.toolkit';
@NgModule({
  declarations: [ExampleComponent],                         // Declare which components, directives and pipes belong to the module
  imports: [ ],                                             // Imports other modules with the components, directives and pipes that components in the current module need
  exports: [ExampleComponent]                               // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {  // Create module class which inherits from the Toolkit module
  constructor() {
      super('Example', 'Creates a template plugin');        // Call the constructor of the parent class
  }
}
</code></pre>
</div>

<div id="pIPC_styles.less" class="tabcontent pipc">
<pre><code class="language-CSS">
p {
    color: white;
}
button {
    position: relative;
    width: 47%;
    height: 3%;
    margin-left: 2%;
    margin-top: 5%;
    color: black;
}
</code></pre>
</div>

<div id="pIPC_template.html" class="tabcontent pipc">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;
&lt;button (click)=&quot;_ng_onRequest()"&gt;'request' to backend&lt;/button&gt;    &lt;!-- Create button for request-type of message --&gt;
&lt;button (click)=&quot;_ng_onSend()"&gt;'send' to backend&lt;/button&gt;          &lt;!-- Create button for send-type of message --&gt;
</code></pre>
</div>

<div id="pIPC_public_api.ts" class="tabcontent pipc">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>

<h2 id="process-part-1"><a class="header" href="#process-part-1">process part</a></h2>

<div class="tab pipcB">
  <button class="tablinks active" onclick="openCode(event, 'pIPC_main.ts')">main.ts</button>
</div>

<div id="pIPC_main.ts" class="tabcontent pipcB active">
<pre><code class="language-Javascript">
import PluginIPCService from 'chipmunk.plugin.ipc';
import { IPCMessages } from 'chipmunk.plugin.ipc';
class Plugin {
    constructor() {
        this._onIncome = this._onIncome.bind(this);
        PluginIPCService.subscribe(IPCMessages.PluginInternalMessage, this._onIncome);                              // <-- Usage of PluginIPCService - Subscribe to incoming messages from UI
    }
    private _onIncome(message: IPCMessages.PluginInternalMessage, response: (res: IPCMessages.TMessage) => any) {   // Message handler for messages from the UI
        switch (message.data.command) {                                                                             // Check incoming command in message from UI
            case 'request':
                return response(new IPCMessages.PluginInternalMessage({                                             // Send response to the UI
                    data: {
                        msg: '\'request\' was successful!'                                                          // Attach string to response
                    },
                    token: message.token,
                    stream: message.stream
                }));
            case 'send':
                return PluginIPCService.sendToPluginHost(message.stream, {                                          // <-- Usage of PluginIPCService - Send message to UI
                    data: {
                        msg: '\'send\' was successful!'                                                             // Attach string to message
                    },
                    event: 'send',
                    streamId: message.stream
                })
            default:
                console.warn(`Unknown command: ${message.data.command}`);
        }
    }
}
const app: Plugin = new Plugin();
</code></pre>
</div>

<h2 id="service_conf"><a class="header" href="#service_conf">4.3 ServiceConfig </a></h2>

The class `ServiceConfig` offers a variety of methods to read and write from an external file. This feature can be used to save and load settings.

> **IMPORTANT**: This module can only be used in the **process part**

```Javascript
// Typescript

/**
 * @class ServiceConfig
 * @description Provides access to plugin configuration.
 */
export declare class ServiceConfig {
    private _path;
    private _alias;
    private _defaults;
    constructor() {}
    /**
     * As default, service trys to find path to settings folder in process.args.
     * This method can be used for manual settings path and alias
     * @param {string} _path - path to folder with settings
     * @param {string} _alias - unique alias of plugin
     */
    setup(_path: string, _alias: string): void;
    /**
     * This method store default settins.
     * Default settings will be used if any settings were not saved before
     * @param {T} defaults - defaults settings
     */
    setDefault<T>(defaults: T): void;
    /**
     * Returns settings from file.
     * @param {T} defaults - defaults settings (optional)
     * @returns {Promise<T>} - T an interface of settings
     */
    read<T>(defaults?: T): Promise<T>;
    /**
     * Saves settings into file
     * @param { {[key: string]: any} } changes - changes of settings.
     * @returns {Promise<void>}
     */
    write(changes?: {
        [key: string]: any;
    }): Promise<void>;
    /**
     * Removes plugin's setting file
     * @returns {Promise<void>}
     */
    drop(): Promise<void>;
    /**
     * Returns name of setting file (with path)
     * @returns {string}
     */
    getFileName(): string;
    private _setProp;
}
```

<h3 id="example---serviceconfig"><a class="header" href="#example---serviceconfig">Example - ServiceConfig</a></h3>

<h2 id="ui-2"><a class="header" href="#ui-2">UI</a></h2>

<div class="tab sc">
  <button class="tablinks" onclick="openCode(event, 'sc_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'sc_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'sc_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'sc_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'sc_public_api.ts')">public_api.ts</button>
</div>

<div id="sc_template.html" class="tabcontent sc">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;
&lt;button (click)=&quot;_ng_onRead()"&gt;Read settings&lt;/button&gt;                               &lt;!-- Create button read settings --&gt;
&lt;button (click)=&quot;_ng_onWrite({id: 1234, name: 'Example'})"&gt;Write settings&lt;/button&gt;  &lt;!-- Create button to write settings--&gt;
</code></pre>
</div>

<div id="sc_styles.less" class="tabcontent sc">
<pre><code class="language-CSS">
p {
    color: white;
}
button {
    position: relative;
    width: 47%;
    height: 3%;
    margin-left: 2%;
    margin-top: 5%;
    color: black;
}
</code></pre>
</div>

<div id="sc_component.ts" class="tabcontent sc active">
<pre><code class="language-Javascript">
import { Component, Input, AfterViewInit, OnDestroy } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
interface IOptions {
    id: number;
    name: string;
}
@Component({
    selector: 'example',
    templateUrl: './template.html',
    styleUrls: ['./styles.less']
})
export class ExampleComponent implements AfterViewInit, OnDestroy {
    @Input() public api: Toolkit.IAPI;                                                              // API assignment
    @Input() public session: string;                                                                // Session ID assignment
    private _subscriptions: { [key: string]: Toolkit.Subscription } = {};                           // Hashlist for session events
    constructor() { }
    ngOnDestroy() {
        Object.keys(this._subscriptions).forEach((key: string) => {                                 // Unsubscribe from all sources when the component is destroyed
            this._subscriptions[key].unsubscribe();
        });
    }
    ngAfterViewInit() {
        this._subscriptions.incomeIPCHostMessage = this.api.getIPC().subscribe((message: any) => {  // Subscribe to process part to listen for messages
            if (typeof message !== 'object' && message === null) {                                  // Check for correct format of message
                return;
            }
            if (message.event === 'config') {                                                       // Check if it's the expected message
                console.log(`Configuration: ${message.data.msg}`);                                  // Print out the message in the console
            }
        });
    }
    public _ng_onRead() {                                                                           // on click function to request settings from the process part
        if (this.api) {                                                                             // check if API exists
            this.api.getIPC().request({                                                             // send request-type of message to the process part
                stream: this.session,
                command: 'read'
            }, this.session).then((response) => {                                                   // Catch response from process part
                console.log(`Settings: ${response.msg}`);                                           // Print out settings in the console
            }).catch((error: Error) => {
                console.error(error);
            });
      } else {
        console.error('No API found!');
      }
    }
    public _ng_onWrite(options: IOptions) {                                                         // on click function for send-type of message to the process part
        if (this.api) {                                                                             // check if API exists
            this.api.getIPC().request({                                                             // send send-type of message to the process part
                stream: this.session,
                command: 'write',
                settings: options
            }, this.session).then((response) => {
                console.log(`Status: ${response.data.status}`);
            }).catch((error: Error) => {
                console.error(error);
            });
        } else {
            console.error('No API found!');
        }
    }
}
</code></pre>
</div>

<div id="sc_module.ts" class="tabcontent sc">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';
import { ExampleComponent } from './component';
import * as Toolkit from 'chipmunk.client.toolkit';
@NgModule({
  declarations: [ExampleComponent],                             // Declare which components, directives and pipes belong to the module
  imports: [ ],                                                 // Imports other modules with the components, directives and pipes that components in the current module need
  exports: [ExampleComponent]                                   // Provides services that the other application components can use
})
export class PluginModule extends Toolkit.PluginNgModule {      // Create module class which inherits from the Toolkit module
  constructor() {
      super('Example', 'Creates a template plugin');            // Call the constructor of the parent class
  }
}
</code></pre>
</div>

<div id="sc_public_api.ts" class="tabcontent sc">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>

<h2 id="process-part-2"><a class="header" href="#process-part-2">process part</a></h2>

<div class="tab scB">
  <button class="tablinks active" onclick="openCode(event, 'sc_main.ts')">main.ts</button>
</div>

<div id="sc_main.ts" class="tabcontent scB active">
<pre><code class="language-Javascript">
import PluginIPCService from 'chipmunk.plugin.ipc';
import { IPCMessages, ServiceConfig } from 'chipmunk.plugin.ipc';
interface IOptions {
    id: number;
    name: string;
}
interface IPort {
    [port: string]: IOptions;
};
interface IPortSettings {
    recent: IPort;
}
class Plugin {
    constructor() {
        this._onIncome = this._onIncome.bind(this);
        PluginIPCService.subscribe(IPCMessages.PluginInternalMessage, this._onIncome);                              // Subscribe to incoming messages from UI
    }
    private _onIncome(message: IPCMessages.PluginInternalMessage, response: (res: IPCMessages.TMessage) => any) {   // Message handler for messages from the UI
        switch (message.data.command) {                                                                             // Check incoming command in message from UI
            case 'write':
                return ServiceConfig.write(settings).then(() => {                                                   // Override current settings
                    response(new IPCMessages.PluginInternalMessage({
                        data: {
                            status: 'done'                                                                          // Send status as response message to the UI
                        },
                        token: message.token,
                        stream: message.stream
                    }));
                }).catch((error: Error) => {
                    reject(error);
                });
            }).catch((error: Error) => {
                this._logger.error(`Failed to write configurations due to the error: ${error.message}`);            // Log error message in case something didn't work
                return reject(error);
            });
            case 'read':
                return ServiceConfig.read<IPortSettings>().then(settings => {                                       // Read current settings
                    response(new IPCMessages.PluginInternalMessage({
                        data: {
                            msg: settings                                                                           // Forward settings as response message to the UI
                        },
                        token: message.token,
                        stream: message.stream
                    }));
                }).catch((error: Error) => {
                    this._logger.error(`Failed to read configurations due to the error: ${error.message}`);         // Log error message in case something didn't work
                    reject(error);
                });
            default:
                console.warn(`Unknown command: ${message.data.command}`);
        }
    }
}
const app: Plugin = new Plugin();
</code></pre>
</div>
-->
<h2 id="logger"><a class="header" href="#logger">4.4 Logger </a></h2>
<p>The <code>API</code> also offers a logger to log any kind of errors or warnings in the <strong>UI</strong>.</p>
<pre><code class="language-Javascript">// Typescript

export default class Logger {
    private _signature;
    private _parameters;
    /**
     * @constructor
     * @param {string} signature        - Signature of logger instance
     * @param {LoggerParameters} params - Logger parameters
     */
    constructor(signature: string, params?: LoggerParameters) {}
    /**
     * Publish info logs
     * @param {any} args - Any input for logs
     * @returns {string} - Formatted log-string
     */
    info(...args: any[]): string;
    /**
     * Publish warnings logs
     * @param {any} args - Any input for logs
     * @returns {string} - Formatted log-string
     */
    warn(...args: any[]): string;
    /**
     * Publish verbose logs
     * @param {any} args - Any input for logs
     * @returns {string} - Formatted log-string
     */
    verbose(...args: any[]): string;
    /**
     * Publish error logs
     * @param {any} args - Any input for logs
     * @returns {string} - Formatted log-string
     */
    error(...args: any[]): string;
    /**
     * Publish debug logs
     * @param {any} args - Any input for logs
     * @returns {string} - Formatted log-string
     */
    debug(...args: any[]): string;
    /**
     * Publish environment logs (low-level stuff, support or tools)
     * @param {any} args - Any input for logs
     * @returns {string} - Formatted log-string
     */
    env(...args: any[]): string;
    private _console;
    private _output;
    private _getMessage;
    private _getTime;
    private _log;
}
</code></pre>
<h3 id="example---logger"><a class="header" href="#example---logger">Example - Logger</a></h3>
<p>In the example below a plugin is created which logs a message.</p>
<div class="tab log">
  <button class="tablinks" onclick="openCode(event, 'log_template.html')">template.html</button>
  <button class="tablinks" onclick="openCode(event, 'log_styles.less')">styles.less</button>
  <button class="tablinks active" onclick="openCode(event, 'log_component.ts')">component.ts</button>
  <button class="tablinks" onclick="openCode(event, 'log_module.ts')">module.ts</button>
  <button class="tablinks" onclick="openCode(event, 'log_public_api.ts')">public_api.ts</button>
</div>
<div id="log_template.html" class="tabcontent log">
<pre><code class="language-HTML">
&lt;p&gt;Example&lt;/p&gt;
</code></pre>
</div>
<div id="log_styles.less" class="tabcontent log">
<pre><code class="language-CSS">
p {
    color: #FFFFFF;
}
</code></pre>
</div>
<div id="log_component.ts" class="tabcontent log active">
<pre><code class="language-Javascript">
import { Component } from '@angular/core';
import * as Toolkit from 'chipmunk.client.toolkit';
@Component({
    selector: 'example',                                                        // Choose the selector name of the plugin
    templateUrl: './template.html',                                             // Assign HTML file as template
    styleUrls: ['./styles.less']                                                // Assign LESS file as style sheet file})
export class ExampleComponent {
    private _logger: Toolkit.Logger = new Toolkit.Logger('Plugin: example: ');  // Instantiate logger with signature   
    constructor() {
        this._logger.debug('Plugin started!');                                  // Create debug message
    }
}
</code></pre>
</div>
<div id="log_module.ts" class="tabcontent log">
<pre><code class="language-Javascript">
import { NgModule } from '@angular/core';                   // Import the Angular component that is necessary for the setup below
import { ExampleComponent } from './component';             // Import the class of the plugin, mentioned in the components.ts file
import * as Toolkit from 'chipmunk.client.toolkit';         // Import Chipmunk Toolkit to let the module class inherit
@NgModule({
    declarations: [ ExampleComponent ],                     // Declare which components, directives and pipes belong to the module 
    imports: [ ],                                           // Imports other modules with the components, directives and pipes that components in the current module need
    exports: [ ExampleComponent ]                           // Provides services that the other application components can use
}
export class PluginModule extends Toolkit.PluginNgModule {  // Create module class which inherits from the Toolkit module
    constructor() {
        super('Example', 'Create an example plugin');       // Call the constructor of the parent class
    }
}
</code></pre>
</div>
<div id="log_public_api.ts" class="tabcontent log">
<pre><code class="language-Javascript">
export * from './component';
export * from './module';
</code></pre>
</div>
<p><a href="02_extensions/04_api.html#api">Go to top</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-for-chipmunk"><a class="header" href="#developing-for-chipmunk">Developing for chipmunk</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-indexer-operation-with-neon-binding"><a class="header" href="#create-indexer-operation-with-neon-binding">create indexer operation with neon binding</a></h1>
<h2 id="rust-implement-streaming-api"><a class="header" href="#rust-implement-streaming-api">Rust: implement streaming API</a></h2>
<p>Since most operations triggered in chipmunk can take some time (mostly working on big files or
streams), all functions should use events/messages to inform the chipmunk about progress, results,
errors and warnings. Below is a description of how to achieve that.</p>
<p>your function should take 2 additional parameters:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>update_channel: mpsc::Sender&lt;IndexingResults&lt;T&gt;&gt;,
shutdown_rx: Option&lt;mpsc::Receiver&lt;()&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>both are rust mpsc channels that can be used for communication between the client using your
function and the function itself. the <code>update_channel</code> is the sender-end of a mpsc channel which
means that your function can use it to send messages to the function-user.
So what should/can your function send? There are 2 basic categories of events you should send:
<code>IndexingProgress&lt;T&gt;</code> messages or <code>Notification</code> messages. We use the <code>Result</code> type to make the
distinction. Kind of like the <code>Either</code> type in haskell. Either we send an <code>Ok(event)</code> or an
<code>Err(notification)</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type IndexingResults&lt;T&gt; = std::result::Result&lt;IndexingProgress&lt;T&gt;, Notification&gt;;
<span class="boring">}</span></code></pre></pre>
<p>In case of an <code>IndexingProgress</code>, you can either send an actual result (<code>GotItem</code>), or report on the
lifecycle state of the function (indicating progress or the end of the function)</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum IndexingProgress&lt;T&gt; {
    GotItem { item: T },
    Progress { ticks: (usize, usize) },
    Stopped,
    Finished,
}
<span class="boring">}</span></code></pre></pre>
<p>Note that for indicating that the function is finished, there are 2 events (<code>Stopped</code> and
<code>Finished</code>) This is to distinguish between "we were stopped from outside" and "we really did
finish").
For all errors that occure and should be communicated to chipmunk, you can send a <code>Notification</code>.
This is a struct that contains the severity, some content and optionally a line number to indicate
at which line the error has occurred.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Notification {
    pub severity: Severity,
    pub content: String,
    pub line: Option&lt;usize&gt;,
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
